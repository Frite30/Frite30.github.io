<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++游戏开发1</title>
    <url>/2024/10/02/C++%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/C++%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%911/</url>
    <content><![CDATA[<p>环境选择:Visual Studio 2022 与 EasyX</p>
<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="渲染缓冲区"><a href="#渲染缓冲区" class="headerlink" title="渲染缓冲区"></a>渲染缓冲区</h2><p><strong>initgraph(x,y);</strong>初始化</p>
<p><strong>cleardevice();</strong>清空当前画布</p>
<h3 id="双缓冲优化"><a href="#双缓冲优化" class="headerlink" title="双缓冲优化"></a>双缓冲优化</h3><p><strong>BeginBatchDraw():</strong>新建画布作为新的渲染缓冲区(默认不可见),随后新的绘图操作将默认在新的画布上进行.</p>
<p><strong>FlushBatchDraw()&amp;EndBatchDraw():</strong>将窗口当前所显示的缓冲区与新的缓冲区进行交换</p>
<h2 id="游戏基本主框架"><a href="#游戏基本主框架" class="headerlink" title="游戏基本主框架"></a>游戏基本主框架</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">初始化（）</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    读取操作();</span><br><span class="line">    处理数据();</span><br><span class="line">    绘制画面();</span><br><span class="line">&#125;</span><br><span class="line">释放资源();</span><br></pre></td></tr></table></figure>
<h1 id="井字棋小游戏的实现"><a href="#井字棋小游戏的实现" class="headerlink" title="井字棋小游戏的实现"></a>井字棋小游戏的实现</h1><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>通过二维数组实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> board_data[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,</span><br><span class="line">	&#123;<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;-&#x27;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> current_piece = <span class="string">&#x27;O&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="读取操作"><a href="#读取操作" class="headerlink" title="读取操作"></a>读取操作</h2><p>只考虑鼠标按键按下的消息进行处理，点击时执行落子操作</p>
<h2 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h2><p>胜负判断(通过函数 枚举进行判断)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckWin</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">0</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">0</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">1</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">2</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">0</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">1</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">0</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">2</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (board_data[<span class="number">0</span>][<span class="number">2</span>] == c &amp;&amp; board_data[<span class="number">1</span>][<span class="number">1</span>] == c &amp;&amp; board_data[<span class="number">2</span>][<span class="number">0</span>] == c)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i=<span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (board_data[i][j] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>游戏结束时用弹窗告诉玩家结果并退出主循环</p>
<h2 id="绘制画面"><a href="#绘制画面" class="headerlink" title="绘制画面"></a>绘制画面</h2><p>应用EasyX函数实现</p>
<p>提示玩家当前落子类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawTipText</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> TCHAR str[<span class="number">64</span>];</span><br><span class="line">	_stprintf_s(str, _T(<span class="string">&quot;当前棋子类型:%c&quot;</span>), current_piece);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">settextcolor</span>(<span class="built_in">RGB</span>(<span class="number">225</span>, <span class="number">175</span>, <span class="number">45</span>));</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">0</span>, <span class="number">0</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>棋盘与棋子的绘制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawBoard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">0</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">200</span>);</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">0</span>, <span class="number">400</span>, <span class="number">600</span>, <span class="number">400</span>);</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">200</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">600</span>);</span><br><span class="line">	<span class="built_in">line</span>(<span class="number">400</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">600</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawPiece</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (board_data[i][j])</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">				<span class="built_in">circle</span>(<span class="number">200</span> * j + <span class="number">100</span>, <span class="number">200</span> * i + <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">				<span class="built_in">line</span>(<span class="number">200</span> * j, <span class="number">200</span> * i, <span class="number">200</span> * (j + <span class="number">1</span>), <span class="number">200</span> * (i + <span class="number">1</span>));</span><br><span class="line">				<span class="built_in">line</span>(<span class="number">200</span> * (j + <span class="number">1</span>), <span class="number">200</span> * i, <span class="number">200</span> * j, <span class="number">200</span> * (i + <span class="number">1</span>));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="游戏主循环"><a href="#游戏主循环" class="headerlink" title="游戏主循环"></a>游戏主循环</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="built_in">initgraph</span>(<span class="number">600</span>, <span class="number">600</span>);</span><br><span class="line"><span class="type">bool</span> running = <span class="literal">true</span>;</span><br><span class="line">ExMessage msg;</span><br><span class="line"><span class="built_in">BeginBatchDraw</span>();</span><br></pre></td></tr></table></figure>
<h3 id="主循环部分"><a href="#主循环部分" class="headerlink" title="主循环部分"></a>主循环部分</h3><p>实现轮流落子功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">peekmessage</span>(&amp;msg))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (msg.message == WM_LBUTTONDOWN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x = msg.x;</span><br><span class="line">		<span class="type">int</span> y = msg.y;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> index_x = x / <span class="number">200</span>;</span><br><span class="line">		<span class="type">int</span> index_y = y / <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (board_data[index_y][index_x] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			board_data[index_y][index_x] = current_piece;</span><br><span class="line">			<span class="keyword">if</span> (current_piece == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">				current_piece = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				current_piece = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cleardevice</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">DrawBoard</span>();</span><br><span class="line"><span class="built_in">DrawPiece</span>();</span><br><span class="line"><span class="built_in">DrawTipText</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">FlushBatchDraw</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">EndBatchDraw</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="胜利检测"><a href="#胜利检测" class="headerlink" title="胜利检测"></a>胜利检测</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">CheckWin</span>(<span class="string">&#x27;X&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), _T(<span class="string">&quot;X 玩家获胜&quot;</span>), _T(<span class="string">&quot;游戏结束&quot;</span>), MB_OK);</span><br><span class="line">	running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CheckWin</span>(<span class="string">&#x27;O&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), _T(<span class="string">&quot;O 玩家获胜&quot;</span>), _T(<span class="string">&quot;游戏结束&quot;</span>), MB_OK);</span><br><span class="line">	running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">CheckDraw</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">MessageBox</span>(<span class="built_in">GetHWnd</span>(), _T(<span class="string">&quot;平局&quot;</span>), _T(<span class="string">&quot;游戏结束&quot;</span>), MB_OK);</span><br><span class="line">	running = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对游戏的优化-帧时动态延时"><a href="#对游戏的优化-帧时动态延时" class="headerlink" title="对游戏的优化(帧时动态延时)"></a>对游戏的优化(帧时动态延时)</h2><p><strong>思路</strong>:对每秒60fps的实现,相比简单的sleep函数,可在主循环开头调用一次函数获取开始时间;主循环结束后再调用一次函数获取结束时间;从而获取一次主循环花费的时间,在此基础上进行优化</p>
<ul>
<li><p><code>DWORD start_time = GetTickCount();</code>//获取开始时间</p>
</li>
<li><p><code>DWORD end_time = GetTickCount();</code>//获取结束时间</p>
</li>
<li><p><code>DWORD delta_time = end_time - start_time;</code>//计算差值</p>
</li>
<li><pre><code>if (delta_time &lt; 1000 / 60)
&#123;
    Sleep(1000 / 60 - delta_time);
&#125;
</code></pre><p><strong>通过对delta_time的计算从而执行具体的sleep时间,实现完整的60fps每秒游戏,使得画面更完整</strong></p>
</li>
</ul>
<p><strong>思想：主循环内应该尽量避免阻塞式的行为或者过于繁重且耗时过长的任务</strong></p>
]]></content>
      <categories>
        <category>C++游戏开发</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Click Here!</title>
    <url>/3000/01/01/TEST/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>C++游戏开发2</title>
    <url>/2025/04/18/C++%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/C++%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%912/</url>
    <content><![CDATA[<h1 id="图片渲染知识"><a href="#图片渲染知识" class="headerlink" title="图片渲染知识"></a>图片渲染知识</h1><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>查看EasyX文档,以加载<em>test.jpg</em>为例</p>
<p><code>IMAGE img;</code></p>
<p><code>loadimage(&amp;img, _T(&quot;test.jpg&quot;));</code></p>
<h2 id="渲染图片"><a href="#渲染图片" class="headerlink" title="渲染图片"></a>渲染图片</h2><p><code>putimage(100,200,&amp;img);</code>//图片左上角坐标</p>
<h2 id="动画基础"><a href="#动画基础" class="headerlink" title="动画基础"></a>动画基础</h2><h3 id="动画的数据逻辑"><a href="#动画的数据逻辑" class="headerlink" title="动画的数据逻辑"></a>动画的数据逻辑</h3><p><strong>确保动画序列帧的能够间隔固定的时间进行切换,类比定时器的概念实现一个计数器</strong></p>
<ul>
<li><p>定义<code>idx_current_anim</code>来存储当前动画的帧索引</p>
</li>
<li><p>定义<code>static int counter</code>变量用来记录当前动画帧一共播放了几个游戏帧</p>
</li>
</ul>
<p>==<strong>使用static确保计数器只在第一个游戏帧被初始化为0</strong>==</p>
<ul>
<li><p>通过if判断语句使得每五个游戏帧切换一个动画帧;随后考虑到动画帧序列播放结束后的行为,当动画的帧索引到达动画帧总数时,将索引重置为0,从而使得动画循环播放</p>
</li>
<li><p>定义<code>const int PLAYER_ANIM_NUM = 6;</code></p>
</li>
<li>使动画循环播放,可书写下列代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (++counter % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">	index_current_anim++;</span><br><span class="line"></span><br><span class="line">index_current_anim = index_current_anim % PLAYER_ANIM_NUM;</span><br></pre></td></tr></table></figure>
<h3 id="动画的渲染"><a href="#动画的渲染" class="headerlink" title="动画的渲染"></a>动画的渲染</h3><p>首先将每一张图片加载到程序中</p>
<ul>
<li><p>定义IMAGE对象数组</p>
<p><code>IMAGE img_player_left[PLAYER_ANIM_NUM];</code><br><code>IMAGE img_player_right[PLAYER_ANIM_NUM];</code></p>
</li>
<li><p>图片命名十分有规律可使用循环来加载图片.在使用Unicode字符集的情况下,可以使用wstring来拼凑出文件的路径,再传递给loadimage函数,将图片传递到数组中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LoadAnimation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; PLAYER_ANIM_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::wstring path = <span class="string">L&quot;img/paimon_left_&quot;</span> + std::<span class="built_in">to_wstring</span>(i) + <span class="string">L&quot;.png&quot;</span>;</span><br><span class="line">		<span class="built_in">loadimage</span>(&amp;img_paimon_left[i], path.<span class="built_in">c_str</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; PLAYER_ANIM_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		std::wstring path = <span class="string">L&quot;img/paimon_right_&quot;</span> + std::<span class="built_in">to_wstring</span>(i) + <span class="string">L&quot;.png&quot;</span>;</span><br><span class="line">		<span class="built_in">loadimage</span>(&amp;img_paimon_right[i], path.<span class="built_in">c_str</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前定义的动画帧索引此时边可以直接当做IMAGE数组的索引来使用</p>
<p><code>putimage(500, 500, &amp;img_paimon_left[index_current_anim]);</code></p>
</li>
</ul>
<h3 id="处理带有透明度的图片素材"><a href="#处理带有透明度的图片素材" class="headerlink" title="处理带有透明度的图片素材"></a>处理带有透明度的图片素材</h3><p>解决思路:类比putimage函数封装一个putimage_alpha函数,借助系统绘图函数比较轻巧的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;MSIMG32.LIB&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">putimage_alpha</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, IMAGE* img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> w = img-&gt;<span class="built_in">getwidth</span>();</span><br><span class="line">	<span class="type">int</span> h = img-&gt;<span class="built_in">getheight</span>();</span><br><span class="line">	<span class="built_in">AlphaBlend</span>(<span class="built_in">GetImageHDC</span>(<span class="literal">NULL</span>), x, y, w, h,</span><br><span class="line">		<span class="built_in">GetImageHDC</span>(img), <span class="number">0</span>, <span class="number">0</span>, w, h, &#123; AC_SRC_OVER,<span class="number">0</span>,<span class="number">255</span>,AC_SRC_ALPHA &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将函数替换<code>putimage_alpha(500, 500, &amp;img_paimon_left[index_current_anim]);</code></p>
<h1 id="键盘控制角色移动"><a href="#键盘控制角色移动" class="headerlink" title="键盘控制角色移动"></a>键盘控制角色移动</h1><h2 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h2><p>定义<code>POINT player_pos = &#123; 500, 500 &#125;;</code>用来存储玩家的位置,并将动画渲染的位置改为player_pos的坐标<code>putimage_alpha(player_pos.x, player_pos.y, &amp;img_paimon_left[index_current_anim]);</code></p>
<p>定义速度 <code>int PLAYER_SPEED = 5;</code></p>
<p>在游戏主循环中通过函数判断键盘按下状态从而实现角色移动效果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg.message == WM_KEYDOWN)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(msg.vkcode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">		player_pos.y -= PLAYER_SPEED;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">		player_pos.y += PLAYER_SPEED;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">		player_pos.x -= PLAYER_SPEED;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">		player_pos.x += PLAYER_SPEED;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>断续:由于当我们按下方向键时,WM_KEYDOWN消息进入事件队列,当保持按键按下一定时间后才会有接连不断的消息被触发</li>
<li>卡顿:keydown消息的产生与游戏主循环异步进行,且触发的频率与操作系统和硬件设备相关,导致有些游戏帧中时间处理部分对多个WM_KEYDOWN消息进行了处理,其余游戏帧中KEY_DOWN较少或几乎没有,导致角色在某些游戏帧中走得远有些走得近</li>
</ul>
<p><strong>实际需求:按键按下时,保证角色在某一个游戏帧中都能连续的移动;即玩家按键按下时,KEYD_DOWN消息触发,标志着角色开始移动,玩家按键抬起时,KEYUP消息触发,标志着角色结束移动</strong></p>
<h2 id="解放方法"><a href="#解放方法" class="headerlink" title="解放方法"></a>解放方法</h2><p><strong>解决思路:定义布尔变量标识玩家运动状态,不直接对玩家的位置数据进行操作而是改变布尔变量的值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义布尔变量用于表示玩家状态</span></span><br><span class="line"><span class="type">bool</span> is_move_up = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_left = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> is_move_right = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//位于游戏主循环中,检测玩家状态</span></span><br><span class="line"><span class="keyword">if</span> (msg.message == WM_KEYDOWN)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span>(msg.vkcode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">		is_move_up = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">		is_move_down = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">		is_move_left = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">		is_move_right = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg.message == WM_KEYUP)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (msg.vkcode)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">		is_move_up = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">		is_move_down = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">		is_move_left = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">		is_move_right = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对玩家移动进行操作</span></span><br><span class="line"><span class="keyword">if</span> (is_move_up) player_pos.y -= PLAYER_SPEED;</span><br><span class="line"><span class="keyword">if</span> (is_move_down) player_pos.y += PLAYER_SPEED;</span><br><span class="line"><span class="keyword">if</span> (is_move_left) player_pos.x -= PLAYER_SPEED;</span><br><span class="line"><span class="keyword">if</span> (is_move_right) player_pos.x += PLAYER_SPEED;</span><br></pre></td></tr></table></figure>
<h1 id="优化动画数据逻辑"><a href="#优化动画数据逻辑" class="headerlink" title="优化动画数据逻辑"></a>优化动画数据逻辑</h1><p>思路:由于代码相似,可使用类的思想进行封装,定义类用于封装动画相关的数据和逻辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animation</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Animation</span>(LPCTSTR path, <span class="type">int</span> num, <span class="type">int</span> interval)&#123;</span><br><span class="line">		interval_ms = interval;</span><br><span class="line"></span><br><span class="line">		TCHAR path_file[<span class="number">256</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">			_stprintf_s(path_file, path, i);</span><br><span class="line"></span><br><span class="line">			IMAGE* frame = <span class="keyword">new</span> <span class="built_in">IMAGE</span>();</span><br><span class="line">			<span class="built_in">loadimage</span>(frame, path_file);</span><br><span class="line">			frame_list.<span class="built_in">push_back</span>(frame);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Animation</span>()&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; frame_list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">delete</span> frame_list[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Play</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">		timer += delta;</span><br><span class="line">		<span class="keyword">if</span> (timer &gt;= interval_ms) &#123;</span><br><span class="line">			idx_frame = (idx_frame + <span class="number">1</span>) % frame_list.<span class="built_in">size</span>();</span><br><span class="line">			timer = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">putimage_alpha</span>(x, y, frame_list[idx_frame]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> timer = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> idx_frame = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> interval_ms = <span class="number">0</span>;</span><br><span class="line">	std::vector&lt;IMAGE*&gt; frame_list;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Animation <span class="title">anim_left_player</span><span class="params">(_T(<span class="string">&quot;img/paimon_left_%d.png&quot;</span>), <span class="number">6</span>, <span class="number">45</span>)</span></span>;</span><br><span class="line"><span class="function">Animation <span class="title">anim_right_player</span><span class="params">(_T(<span class="string">&quot;img/paimon_right_%d.png&quot;</span>), <span class="number">6</span>, <span class="number">45</span>)</span></span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++游戏开发</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记10</title>
    <url>/2025/01/27/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B010/</url>
    <content><![CDATA[<h2 id="结构体区别"><a href="#结构体区别" class="headerlink" title="结构体区别"></a>结构体区别</h2><p><code>struct</code>和<code>class</code>仅仅只有默认的访问控制不同</p>
<p><code>struct</code>默认是public，<code>class</code>默认是private</p>
<p>如果数据只是简单的聚合就用<code>struct</code>,如果用于表示行为和状态的复杂对象，不能随意让外部访问，则用<code>class</code>(这种访问控制的能力就是<strong>封装性</strong>，类的重要特性)</p>
<p>通过类定义的变量称之为对象</p>
<h2 id="类的操作"><a href="#类的操作" class="headerlink" title="类的操作"></a>类的操作</h2><p>访问控制：<code>private, protected, public, friend</code></p>
<p>用于初始化的函数称为<strong>构造函数</strong></p>
<p><strong>析构函数</strong>用于对象销毁时做清理，调用时机是对象被销毁时，不管是栈中的对象被自动销毁，还是<code>new</code>出来的对象被手动<code>delete</code>，都会自动调用析构函数</p>
<p><strong>成员函数</strong> 在对象内写的函数（只有public才能被外部调用，如果是private只能在成员函数内被调用）</p>
<p>成员函数的<code>this</code>指针指向对象自身，默认会传递</p>
<p>运算符重载(操作符重载)可以让内置的运算符进行重解释，可以将函数名改成对应的操作符，需要加上<code>operator</code>关键字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span> &#123;</span><br><span class="line">    <span class="type">int</span>* digits = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">const</span> string &amp;str, int_sign)&#123;</span><br><span class="line">        <span class="comment">//构造函数</span></span><br><span class="line">        size = str.<span class="built_in">size</span>();</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">BigInt</span>()&#123;</span><br><span class="line">        <span class="comment">//析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="type">const</span> BigInt &amp;x) &#123;&#125;</span><br><span class="line">    <span class="function">BigInt&amp; <span class="title">self_add</span><span class="params">(<span class="type">const</span> BigInt &amp;x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一般运算符都是由左右两部分组成的 <code>lhs operator rhs</code></p>
<p>重载运算符的操作就是右边的操作数<code>auto operator-(const Type &amp;rhs)&#123;&#125;</code></p>
<p><code>explicit</code>关键字代表必须显式转化，类型转化运算符使用，避免因为二义性带来问题</p>
<p><code>friend</code>友元，在类中声明并加上友元声明，就可以在其他位置进行访问该类的私有成员，也可以单独对类的某个成员函数声明为友元<code>friend double BigFloat::pow(BigInt&amp;);</code></p>
<p>成员函数的其他命名方法：<code>BigInt BigInt::add(BigInt &amp;X) &#123;&#125;</code></p>
<h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><p><strong>继承</strong>：继承另一个类的成员变量和函数，方便复用</p>
<p>可访问父类非私有的成员，继承方式影响成员在子类的权限</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, w, h;</span><br><span class="line">    <span class="type">int</span> hp, attack;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">test</span><span class="params">(Obj* other)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plant</span> : Obj &#123;</span><br><span class="line">    <span class="comment">// Plant为子类（派生类）	Obj为父类（基类）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类可以访问public和protected成员，不能访问private成员</p>
<p>关键字 ==final== 如果一个类被final修饰，则这个类不能被继承</p>
<p>构造函数无法被继承，需要显式声明，先父再子</p>
<p>析构函数无法被继承，先子后父，建议写成虚函数</p>
<p>纯虚函数不需要实现，但是在子类中必须重写</p>
<p>虚函数的实现原理是虚函数表</p>
<p><strong>虚函数</strong>  —&gt;  动态<strong>多态</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Zombie</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attack</span> <span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//加上virtual关键字代表是虚函数，才可以在子类中重写</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">clicked</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//纯虚函数，如果一个类有纯虚函数，则不能创建基类对象，只能创建子类对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gargantuar</span> : <span class="keyword">public</span> Zombie &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attack</span> <span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;; <span class="comment">//override代表这个函数是对虚函数的重写  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例子：高精度大数"><a href="#例子：高精度大数" class="headerlink" title="例子：高精度大数"></a>例子：高精度大数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bint</span> &#123;</span><br><span class="line">  <span class="type">int</span> *digits = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">delete</span>[] digits;</span><br><span class="line">      digits = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = len;</span><br><span class="line">    digits = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">trim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(size &gt; <span class="number">1</span> &amp;&amp; digits[size - <span class="number">1</span>] == <span class="number">0</span>) size --;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">bint</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">delete</span>[] digits;</span><br><span class="line">    digits = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  bint&amp; <span class="keyword">operator</span>=(<span class="type">const</span> bint &amp;rhs)&#123;</span><br><span class="line">    <span class="built_in">reset</span>(rhs.size);</span><br><span class="line">    <span class="built_in">memcpy</span>(digits, rhs.digits, <span class="built_in">sizeof</span>(<span class="type">int</span>) * size);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  bint&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;rhs)&#123;</span><br><span class="line">    <span class="built_in">reset</span>(rhs.<span class="built_in">length</span>());</span><br><span class="line">    size = rhs.<span class="built_in">size</span>();</span><br><span class="line">    digits = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">      digits[i] = rhs[size - <span class="number">1</span> - i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> bint &amp;rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span>(size != rhs.size) <span class="keyword">return</span> size &lt; rhs.size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = size - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --)&#123;</span><br><span class="line">      <span class="keyword">if</span>(digits[i] != rhs.digits[i])&#123;</span><br><span class="line">        <span class="keyword">return</span> digits[i] &lt; rhs.digits[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  bint <span class="keyword">operator</span>-(<span class="type">const</span> bint &amp;rhs)&#123;</span><br><span class="line">    bint ret;</span><br><span class="line">    ret = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size; i ++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; rhs.size) ret.digits[i] -= rhs.digits[i];</span><br><span class="line">      <span class="keyword">if</span>(ret.digits[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret.digits[i] += <span class="number">10</span>;</span><br><span class="line">        ret.digits[i + <span class="number">1</span>] --;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.<span class="built_in">trim</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  bint <span class="keyword">operator</span>+(<span class="type">const</span> bint &amp;rhs)&#123;</span><br><span class="line">    bint ret;</span><br><span class="line">    ret.size = <span class="built_in">max</span>(size, rhs.size) + <span class="number">1</span>;</span><br><span class="line">    ret.digits = <span class="keyword">new</span> <span class="type">int</span>[ret.size];</span><br><span class="line">    <span class="built_in">memset</span>(ret.digits, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * ret.size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret.size - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; size) ret.digits[i] += digits[i];</span><br><span class="line">      <span class="keyword">if</span> (i &lt; rhs.size) ret.digits[i] += rhs.digits[i];</span><br><span class="line">      <span class="keyword">if</span> (ret.digits[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        ret.digits[i] -= <span class="number">10</span>;</span><br><span class="line">        ret.digits[i + <span class="number">1</span>] ++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.<span class="built_in">trim</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;lhs, bint &amp;rhs)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    lhs &gt;&gt; str;</span><br><span class="line">    rhs = str;</span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;lhs, <span class="type">const</span> bint &amp;rhs)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = rhs.size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">      lhs &lt;&lt; rhs.digits[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  bint a, b;</span><br><span class="line">  cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="keyword">if</span>(a &lt; b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;-&#x27;</span> &lt;&lt; b - a &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>在C++中，重载运算符是否加<code>&amp;</code>（引用符号）主要取决于运算符的语义和使用场景。以下是详细说明：</p>
<h3 id="加-amp-的情况"><a href="#加-amp-的情况" class="headerlink" title="加&amp;的情况"></a><strong>加<code>&amp;</code>的情况</strong></h3><ul>
<li><p><strong>返回左值引用的情况</strong></p>
<ul>
<li>当重载的运算符需要返回一个左值（可以被赋值的对象）时，通常会加<code>&amp;</code>。例如，重载赋值运算符<code>=</code>时，通常返回一个左值引用，以便支持链式赋值。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 实现赋值操作</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样可以支持如下链式赋值：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass a, b, c;</span><br><span class="line">a = b = c;</span><br></pre></td></tr></table></figure></li>
<li>重载下标运算符<code>[]</code>时，也通常返回左值引用，以便可以对返回的对象进行赋值操作。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">    <span class="comment">// 返回数组元素的引用</span></span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样可以支持如下操作：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">obj[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 通过下标运算符返回的引用进行赋值</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>避免不必要的拷贝</strong><ul>
<li>当重载运算符的返回值是一个较大的对象时，为了避免不必要的拷贝，可以返回引用。例如，重载输入运算符<code>&gt;&gt;</code>时，通常返回<code>istream&amp;</code>，以避免拷贝输入流对象。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, MyClass&amp; obj) &#123;</span><br><span class="line">    <span class="comment">// 从输入流读取数据到obj</span></span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="不加-amp-的情况"><a href="#不加-amp-的情况" class="headerlink" title="不加&amp;的情况"></a><strong>不加<code>&amp;</code>的情况</strong></h3><ul>
<li><strong>返回右值的情况</strong><ul>
<li>当重载的运算符需要返回一个临时对象（右值）时，不加<code>&amp;</code>。例如，重载加法运算符<code>+</code>时，通常返回一个临时对象。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass <span class="keyword">operator</span>+(<span class="type">const</span> MyClass&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">temp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    temp += rhs;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里返回的是一个临时的<code>MyClass</code>对象，而不是引用。</li>
</ul>
</li>
<li><strong>返回布尔值的情况</strong><ul>
<li>当重载的运算符返回布尔值时，也不加<code>&amp;</code>。例如，重载比较运算符<code>==</code>、<code>!=</code>等。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyClass&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// 比较逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 或 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>返回指针的情况</strong><ul>
<li>当重载的运算符返回指针时，也不加<code>&amp;</code>。例如，重载成员访问运算符<code>-&gt;</code>时，返回一个指针。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass* <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a><strong>特殊情况</strong></h3><ul>
<li><strong>重载下标运算符<code>[]</code>的常量版本</strong><ul>
<li>如果重载的下标运算符是常量成员函数，需要返回一个常量引用，以保证返回的对象不能被修改。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>这样可以防止通过下标运算符修改对象的成员变量。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>加<code>&amp;</code></strong>：当需要返回左值引用（如赋值运算符、下标运算符等）或者避免不必要的拷贝（如输入运算符）时。</li>
<li><strong>不加<code>&amp;</code></strong>：当返回临时对象（如加法运算符）、布尔值、指针等情况时。</li>
</ul>
<p>根据具体的运算符语义和使用场景选择是否加<code>&amp;</code>，可以更好地实现代码的效率和语义正确性。</p>
<h2 id="动态联编"><a href="#动态联编" class="headerlink" title="动态联编"></a>动态联编</h2><p>在面向对象编程中，<strong>动态联编（Dynamic Binding）</strong> 是一种机制，允许在运行时根据对象的实际类型来调用相应的函数。基类指针动态联编调用派生类的函数，通常涉及到 <strong>多态（Polymorphism）</strong> 和 <strong>虚函数（Virtual Function）</strong>。以下为你详细解释并举例说明：</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><strong>基类与派生类</strong> ：基类是定义了一些通用属性和行为的类，派生类是从基类继承而来的类，可以继承基类的成员，并且可以添加新的成员或重写（Override）基类的成员函数。</li>
<li><strong>虚函数</strong> ：在基类中声明为 <code>virtual</code> 的函数。当通过基类指针或引用调用虚函数时，会根据对象的实际类型来调用相应的函数，而不是根据指针或引用的类型。这是实现动态联编的关键。</li>
<li><strong>动态联编</strong> ：在运行时根据对象的实际类型来确定调用哪个函数。与之相对的是静态联编（Static Binding），静态联编是在编译时就确定调用哪个函数。</li>
</ul>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>假设有一个基类 <code>Animal</code> 和两个派生类 <code>Dog</code> 和 <code>Cat</code>，基类中有一个虚函数 <code>makeSound()</code>，派生类重写了这个函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal makes a sound&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Dog</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Dog barks&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat meows&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建基类指针</span></span><br><span class="line">    Animal* animalPtr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建派生类对象</span></span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将基类指针指向派生类对象</span></span><br><span class="line">    animalPtr = &amp;dog;</span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 输出 &quot;Dog barks&quot;</span></span><br><span class="line"></span><br><span class="line">    animalPtr = &amp;cat;</span><br><span class="line">    animalPtr-&gt;<span class="built_in">makeSound</span>(); <span class="comment">// 输出 &quot;Cat meows&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中：</p>
<ul>
<li><code>Animal</code> 是基类，<code>Dog</code> 和 <code>Cat</code> 是派生类。</li>
<li><code>makeSound()</code> 是基类中的虚函数，<code>Dog</code> 和 <code>Cat</code> 分别重写了这个函数。</li>
<li>在 <code>main()</code> 函数中，创建了一个基类指针 <code>animalPtr</code>，然后分别将它指向 <code>Dog</code> 和 <code>Cat</code> 对象。</li>
<li>当通过 <code>animalPtr</code> 调用 <code>makeSound()</code> 函数时，会根据 <code>animalPtr</code> 指向的对象的实际类型（<code>Dog</code> 或 <code>Cat</code>）来调用相应的函数，而不是调用基类 <code>Animal</code> 中的 <code>makeSound()</code> 函数。这就是动态联编的体现。</li>
</ul>
<p>如果 <code>makeSound()</code> 函数不是虚函数，那么通过基类指针调用函数时，就会调用基类中的函数，而不会根据对象的实际类型调用派生类中的函数，这就是静态联编的行为。</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记12</title>
    <url>/2025/01/28/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B012/</url>
    <content><![CDATA[<h2 id="文件输入输出-c语言"><a href="#文件输入输出-c语言" class="headerlink" title="文件输入输出 c语言"></a>文件输入输出 c语言</h2><p>c语言使用<code>fopen(const char* fileName, const char* mode);</code>返回对应文件的指针<code>FILE*</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">文件不存在</th>
<th style="text-align:center">是否可读</th>
<th style="text-align:center">如何写入</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“r”</td>
<td style="text-align:center">出错</td>
<td style="text-align:center">是</td>
<td style="text-align:center">不可泄</td>
</tr>
<tr>
<td style="text-align:center">“w”</td>
<td style="text-align:center">创建</td>
<td style="text-align:center">否</td>
<td style="text-align:center">清空后写入</td>
</tr>
<tr>
<td style="text-align:center">“a”</td>
<td style="text-align:center">创建</td>
<td style="text-align:center">否</td>
<td style="text-align:center">追加写入</td>
</tr>
<tr>
<td style="text-align:center">“r+”</td>
<td style="text-align:center">出错</td>
<td style="text-align:center">是</td>
<td style="text-align:center">覆盖式写入</td>
</tr>
<tr>
<td style="text-align:center">“w+”</td>
<td style="text-align:center">创建</td>
<td style="text-align:center">是</td>
<td style="text-align:center">清空后写入</td>
</tr>
<tr>
<td style="text-align:center">“a+”</td>
<td style="text-align:center">创建</td>
<td style="text-align:center">是</td>
<td style="text-align:center">追加写入</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FILE* file = <span class="built_in">fopen</span>(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;open file failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开文件后可以使用<code>fscanf</code>来读取文件的数据    <code>fscanf(file, &quot;%d %d&quot;, &amp;a, &amp;b);</code></p>
<p>或用<code>fprintf</code>来向文件写入数据    <code>fprintf(file, &quot;%d\n&quot;, a + b);</code></p>
<p>第一个参数需要传入文件的指针</p>
<p><code>char ch = fgetc(file);</code>    <code>fputc(ch, file);</code>获取和输出单个字符</p>
<p><code>fgets(str, 100, file);</code>    <code>fputs(str, file);</code> 来读入和输出整行的字符串</p>
<p>使用完文件后 调用<code>fclose(file);</code>进行关闭</p>
<h2 id="文件输入输出-c"><a href="#文件输入输出-c" class="headerlink" title="文件输入输出 c++"></a>文件输入输出 c++</h2><p>在头文件 <code>&lt;fstream&gt;</code>中 通过<code>fstream</code>类型来定义文件流</p>
<p><code>fstream fio(&quot;text.txt&quot;, ios::in | ios::out | ios::app);</code></p>
<p>其中in代表读入 out代表清空后写入 app是append的缩写，代表追加，多个模式相加使用<code>|</code></p>
<ul>
<li><code>ifstream openFileIn(&quot;filename&quot;, ios::in);</code>：打开文件用于读取</li>
<li><code>ofstream openFileOut(&quot;filename&quot;, ios::out);</code>：打开文件用于写入</li>
<li><code>fstream openFileInOut(&quot;filename&quot;, ios::in | ios::out);</code>：打开文件用于读写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">fio</span><span class="params">(<span class="string">&quot;text.txt&quot;</span>, ios::in | ios::out | ios::app)</span></span>;</span><br><span class="line">fio &gt;&gt; a &gt;&gt; b;</span><br><span class="line">fio &lt;&lt; a &lt;&lt; b;</span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>, ios::app)</span></span>;</span><br><span class="line">fin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">fout &lt;&lt; a &lt;&lt; b;</span><br></pre></td></tr></table></figure>
<p><code>fio.close(), fin.close(), fout.close();</code>进行关闭</p>
<p><strong>文件读写</strong></p>
<ul>
<li><p><code>char ch; fileIn.get(ch);</code>：从文件中读取一个字符</p>
</li>
<li><p><code>string str; getline(fileIn, str);</code>：从文件中读取一行字符串</p>
</li>
<li><p><code>char ch = &#39;A&#39;; fileOut.put(ch);</code>：向文件写入一个字符</p>
</li>
<li><p><code>fout.write(const char* str, streamsize n);</code></p>
</li>
<li><p><code>string str = &quot;Hello&quot;; fileOut &lt;&lt; str;</code>：向文件写入一个字符串</p>
</li>
</ul>
<p><strong>移动文件指针</strong></p>
<ul>
<li><code>fileIn.seekg(0, ios::beg);</code>：将输入文件指针移动到文件开头</li>
<li><code>fileOut.seekp(0, ios::beg);</code>：将输出文件指针移动到文件开头</li>
</ul>
<p><strong>文件状态检查</strong></p>
<ul>
<li><p><code>if (fileIn.eof()) &#123; ... &#125;</code>：检查是否到达文件末尾</p>
</li>
<li><p><code>if (!fileIn) &#123; ... &#125;</code>：检查文件是否打开失败或发生错误</p>
</li>
</ul>
<p>在头文件<code>&lt;sstream&gt;</code>中 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">string str = <span class="string">&quot;1 2&quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">ss &gt;&gt; a &gt;&gt; b;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记1</title>
    <url>/2024/10/01/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h2 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h2><p>第一位是0则表示false</p>
<p>否则表示true(1)</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h3 id="auto-可自动推导类型"><a href="#auto-可自动推导类型" class="headerlink" title="==auto== 可自动推导类型"></a>==auto== 可自动推导类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> var_i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> var_c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">auto</span> var_b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">auto</span> var_d = <span class="number">3.14</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(var_i).<span class="built_in">name</span>() &lt;&lt; endl;<span class="comment">//输出i,其余同理输出对应数据类型</span></span><br></pre></td></tr></table></figure>
<h2 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h2><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="number">255</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);<span class="comment">//%d 十进制;%o 八进制;%x 十六进制;</span></span><br><span class="line"><span class="comment">//在前面加上# 即可输出对应进制 如 &quot;%#x\n&quot;,d 输出得到0xff 表示16进制(八进制前跟0;十六进制前跟0x)</span></span><br></pre></td></tr></table></figure>
<p>printf中输出不同大小的整形时,需要在类型前加大小修饰符</p>
<p>s<strong>h</strong>ort <strong>l</strong>ong <strong>l</strong>ong<strong>l</strong>ong</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> lld = <span class="number">2147486948</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, lld)</span><br></pre></td></tr></table></figure>
<h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>printf输出字符型用%c</p>
<h4 id="输出宽度"><a href="#输出宽度" class="headerlink" title="输出宽度"></a>输出宽度</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%7d|\n&quot;</span>, d);<span class="comment">//右对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-7d|\n&quot;</span> d);<span class="comment">//左对齐</span></span><br></pre></td></tr></table></figure>
<h3 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h3><h4 id="数字类型-1"><a href="#数字类型-1" class="headerlink" title="数字类型"></a>数字类型</h4><p>C++中进行优化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; oct;</span><br><span class="line"><span class="comment">//cout &lt;&lt; dec; 十进制</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; hex; 十六进制</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; uppercase; 十六进制字母显示为大写(nouppercase小写)</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; showbase; 数字前显示进制符号</span></span><br><span class="line">cout.<span class="built_in">setf</span>(ios::oct, ios::basefield);</span><br><span class="line">cout.<span class="built_in">flag</span>(ios::oct);</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setbase</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<h4 id="字符型-1"><a href="#字符型-1" class="headerlink" title="字符型"></a>字符型</h4><p>cout直接输出字符型 cout &lt;&lt; c &lt;&lt; endl;</p>
<p><img src="E:\Blog\source\img\fixed pre.png" alt="fixed pre"></p>
<p>cout.precision();限制的是输出数字的个数</p>
<p>加上cout &lt;&lt; fixed; 限制则是输出小数点后的个数</p>
<h4 id="输出宽度-1"><a href="#输出宽度-1" class="headerlink" title="输出宽度"></a>输出宽度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">width</span>(<span class="number">7</span>);</span><br><span class="line">cout &lt;&lt; d &lt;&lt; <span class="string">&#x27;|&#x27;</span> &lt;&lt; endl;<span class="comment">//仅生效一次 默认右对齐</span></span><br><span class="line">cout &lt;&lt; left;<span class="comment">//来控制左右</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> cout.<span class="built_in">width</span>(<span class="number">3</span>);</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"><span class="comment">//cout输入3位,不足3位时补0,例如res = 8,输出008</span></span><br></pre></td></tr></table></figure>
<h3 id="format-C-20-新特性"><a href="#format-C-20-新特性" class="headerlink" title="format(C++ 20 新特性)"></a>format(C++ 20 新特性)</h3><h4 id="数字类型-2"><a href="#数字类型-2" class="headerlink" title="数字类型"></a>数字类型</h4><p>C++ 20 取二者之长</p>
<p><img src="E:\Blog\source\img\format.png" alt="format"></p>
<p>cout &lt;&lt; format(“{}”, c) &lt;&lt; endl;</p>
<p><img src="E:\Blog\source\img\fixed pre format.png" alt="fixed pre format"></p>
<h4 id="输出宽度-2"><a href="#输出宽度-2" class="headerlink" title="输出宽度"></a>输出宽度</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; format(<span class="string">&quot;&#123;:&gt;7&#125;|&quot;</span>, d) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// &gt;右对齐 &lt;左对齐 ^居中对齐</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="E:\Blog\source\img\sum up.png" alt="sum up"></p>
<h2 id="补充sprintf"><a href="#补充sprintf" class="headerlink" title="补充sprintf"></a>补充<code>sprintf</code></h2><p><code>sprintf</code> 是一个在 C 和 C++ 语言中使用的函数，它属于标准库中的输入/输出部分。<code>sprintf</code> 函数的作用是将格式化的数据写入一个字符串中，类似于 <code>printf</code> 函数，但它将输出写入一个字符串变量而不是直接输出到控制台。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>str</code>：指向目标字符串的指针，<code>sprintf</code> 会将格式化后的字符串存储在这里。</li>
<li><code>format</code>：格式化字符串，它指定了后续参数如何被格式化和插入到最终的字符串中。</li>
<li><code>...</code>：可变参数列表，这些参数将根据 <code>format</code> 字符串中的格式说明符被格式化并插入到字符串中。</li>
</ul>
<p><code>sprintf</code> 的使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;The answer is %d&quot;</span>, num);</span><br><span class="line"><span class="comment">// 此时 buffer 包含了字符串 &quot;The answer is 42&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>%d</code> 是一个格式说明符，它告诉 <code>sprintf</code> 将一个整数转换成字符串并插入到 <code>buffer</code> 中。</p>
<p>在下面这个例子，<code>sprintf</code>很好的处理的时间点小于0的问题，将3:30补充为03：30。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">getstr</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%02d&quot;</span>, a);</span><br><span class="line">    <span class="function">string <span class="title">h</span><span class="params">(buf)</span></span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%02d&quot;</span>, b);</span><br><span class="line">    <span class="function">string <span class="title">m</span><span class="params">(buf)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> h + <span class="string">&quot;:&quot;</span> + m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>sprintf</code> 存在安全风险，因为它可能导致缓冲区溢出，如果格式化后的字符串长度超过了 <code>buffer</code> 的大小。因此，在实际编程中，推荐使用 <code>snprintf</code> 函数，它允许你指定目标缓冲区的最大长度，从而避免溢出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure>
<p><code>size</code> 参数指定了 <code>str</code> 缓冲区的最大长度，<code>snprintf</code> 会在达到这个长度之前停止写入，并且总是以空字符结尾。这样可以更安全地避免缓冲区溢出的问题。</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记13</title>
    <url>/2025/02/28/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B013/</url>
    <content><![CDATA[<h1 id="常见的位运算"><a href="#常见的位运算" class="headerlink" title="常见的位运算"></a>常见的位运算</h1><h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><p>~ （取反）</p>
<p>| （或）</p>
<p>&amp; （与）</p>
<p>^ （异或）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取相反数，`e = ~ a + 1`</span></span><br><span class="line"><span class="type">int</span> g = <span class="number">0b0001010</span>;</span><br><span class="line"><span class="type">int</span> h = <span class="number">0b0001100</span>;</span><br><span class="line">cout &lt;&lt; (g | h); <span class="comment">//或运算，每一位只要有一位有1，就能够保留</span></span><br><span class="line">cout &lt;&lt; (g &amp; h); <span class="comment">//与运算，只有两位都是1，才可以保留</span></span><br><span class="line">cout &lt;&lt; (g ^ h); <span class="comment">//异或，相同就是0，不同就是1</span></span><br></pre></td></tr></table></figure>
<h2 id="lt-lt-（左移）"><a href="#lt-lt-（左移）" class="headerlink" title="&lt;&lt; （左移）"></a>&lt;&lt; （左移）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//整体状态向左移动,用0补右边</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0b0011010</span>;</span><br><span class="line">cout &lt;&lt; (i &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">//000000&#x27;1101&#x27;0</span></span><br><span class="line"><span class="comment">//00000&#x27;1101&#x27;00</span></span><br></pre></td></tr></table></figure>
<h2 id="gt-gt-gt-gt-gt-（右移）"><a href="#gt-gt-gt-gt-gt-（右移）" class="headerlink" title="&gt;&gt;  , &gt;&gt;&gt;（右移）"></a>&gt;&gt;  , &gt;&gt;&gt;（右移）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对非负数效果一样,向右移,并且用0来补充左边</span></span><br><span class="line"><span class="comment">//而对负数效果不一样</span></span><br><span class="line"><span class="comment">//&#x27;&gt;&gt;&#x27;用符号位来补;&#x27;&gt;&gt;&gt;&#x27;一律用0来补位</span></span><br><span class="line"><span class="comment">//1111 0000 0000 (分别向右移动2位)</span></span><br><span class="line"><span class="comment">//1111 1100 0000 </span></span><br><span class="line"><span class="comment">//0011 1100 0000</span></span><br></pre></td></tr></table></figure>
<h1 id="数学性质"><a href="#数学性质" class="headerlink" title="数学性质"></a>数学性质</h1><ol>
<li>对于<strong>非负数</strong>来说:</li>
</ol>
<ul>
<li>非负数 &lt;&lt; i ，等同于乘以2的i次方</li>
<li>非负数 &gt;&gt; i ，等同于除以2的i次方</li>
</ul>
<ol>
<li><strong>一个数异或自身奇数次还是自身，偶数次则为0</strong></li>
</ol>
<p>​    x ^ x = 0; x ^ 0 = x</p>
<ol>
<li>通过异或还可以不用中间变量来交换两个整形 </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = x ^ y;</span><br><span class="line">y = x ^ y;</span><br><span class="line">x = x ^ y;</span><br></pre></td></tr></table></figure>
<ol>
<li>左移1在不溢出的情况下等价于乘以2</li>
</ol>
<p>​       右移代表整除2，不过只针对正数，如果是负数，则代表向上取整的整除2</p>
<ol>
<li><p>两个质数异或值为1 代表两个数字前后最多相差1</p>
</li>
<li><p><code>__builtin_clz(n)</code> 计算二进制中最高位1左边0的个数（前导零的个数）</p>
</li>
<li><code>__builtin_ctz(n)</code>计算二进制中末尾0连续的个数（尾随零的个数）</li>
</ol>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记11</title>
    <url>/2025/01/28/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B011/</url>
    <content><![CDATA[<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a><code>sort</code></h2><p>排序，复杂度为O(nlogn)</p>
<p><code>sort(Iterator begin, Iterator end, Function comp)</code></p>
<h2 id="nth-element"><a href="#nth-element" class="headerlink" title="nth_element"></a><code>nth_element</code></h2><p>将第n小的数字移动到第n位，复杂度O(n)</p>
<p><code>nth_element(Iterator begin, Iterator nth, Iterator end, Function comp)</code></p>
<p><code>nth_element(a,begin(), a.begin()+ k, a.end());</code></p>
<p>此时输出a[k]的值能得到第k小的数字</p>
<h2 id="lower-bound-amp-upper-bound"><a href="#lower-bound-amp-upper-bound" class="headerlink" title="lower_bound &amp; upper_bound"></a><code>lower_bound</code> &amp; <code>upper_bound</code></h2><p>传入参数相同皆为<code>Iterator begin, Iterator end, Type v, Function comp</code></p>
<p><strong>在有序的数组中</strong> lower_bound -&gt; 找到第一个大于等于v的迭代器</p>
<p>​                          upper_bound -&gt; 找到第一个大于v的迭代器</p>
<p>复杂度为O(logn)</p>
<h2 id="next-permutation-amp-prev-permutation"><a href="#next-permutation-amp-prev-permutation" class="headerlink" title="next_permutation &amp; prev_permutation"></a><code>next_permutation</code> &amp; <code>prev_permutation</code></h2><p><code>next_permutation</code> 和 <code>prev_permutation</code> 是 C++ 标准模板库（STL）中的两个算法函数，用于生成给定序列的下一个和上一个排列。</p>
<h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a><code>next_permutation</code></h3><ul>
<li><strong>函数原型</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>参数</strong>：<ul>
<li><code>first</code> 和 <code>last</code>：定义了排列范围的双向迭代器，表示 <code>[first, last)</code> 区间。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果存在下一个排列，则返回 <code>true</code>，并更新序列；如果当前序列已经是最后一个排列，则返回 <code>false</code>，序列保持不变。</li>
</ul>
<h3 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a><code>prev_permutation</code></h3><ul>
<li><strong>函数原型</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">BidirectionalIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prev_permutation</span><span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>参数</strong>：<ul>
<li><code>first</code> 和 <code>last</code>：定义了排列范围的双向迭代器，表示 <code>[first, last)</code> 区间。</li>
</ul>
</li>
<li><strong>返回值</strong>：如果存在上一个排列，则返回 <code>true</code>，并更新序列；如果当前序列已经是第一个排列，则返回 <code>false</code>，序列保持不变。</li>
</ul>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul>
<li>序列必须是可排列的，即元素必须支持 <code>operator&lt;</code> 运算。</li>
<li>序列必须是有序的，即所有元素都按照某种顺序排列。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个使用 <code>next_permutation</code> 和 <code>prev_permutation</code> 的示例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : v) &#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;所有排列生成完毕，现在使用 prev_permutation 回溯到上一个排列&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">prev_permutation</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>())) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : v) &#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 2</span><br><span class="line">2 1 3</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">3 2 1</span><br><span class="line">所有排列生成完毕，现在使用 prev_permutation 回溯到上一个排列</span><br><span class="line">3 1 2</span><br><span class="line">2 3 1</span><br><span class="line">2 1 3</span><br><span class="line">1 3 2</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>生成所有可能的排列。</li>
<li>在排列中查找特定的排列。</li>
<li>实现回溯算法。</li>
</ul>
<p>总之，<code>next_permutation</code> 和 <code>prev_permutation</code> 是两个强大的排列生成工具，可以用于生成和操作序列的所有排列。</p>
<h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a><code>unique</code></h2><h3 id="函数作用"><a href="#函数作用" class="headerlink" title="函数作用"></a>函数作用</h3><p><code>std::unique</code> 函数的作用是移除容器中所有连续重复的元素，只保留每个元素的第一个出现。它不会真正从容器中删除元素，而是将所有重复的元素移动到容器的末尾，并返回一个新的迭代器，指向新的逻辑结束位置。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p><code>std::unique</code> 函数返回的迭代器是一个<strong>指向新逻辑结束位置</strong>的迭代器。这个迭代器指向的位置是第一个不重复元素之后的位置，即所有重复元素都被移动到这个位置之后。</p>
<h3 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h3><p><code>unique(v.begin(), v.end())</code> 返回的迭代器类型与传入的迭代器类型相同。如果 <code>v</code> 是一个 <code>std::vector</code>，那么返回的迭代器就是 <code>std::vector&lt;int&gt;::iterator</code> 类型；如果 <code>v</code> 是一个 <code>std::list</code>，那么返回的迭代器就是 <code>std::list&lt;int&gt;::iterator</code> 类型。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>假设 <code>v</code> 是一个 <code>std::vector&lt;int&gt;</code>，那么 <code>v.begin()</code> 和 <code>v.end()</code> 分别是指向 <code>v</code> 的第一个元素和最后一个元素之后的位置的迭代器。<code>unique(v.begin(), v.end())</code> 会处理这个范围内的所有元素，移除连续重复的元素，并返回一个新的迭代器，指向新的逻辑结束位置。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>这个返回的迭代器通常用于与容器的 <code>erase</code> 方法结合使用，以实际从容器中移除重复元素.<code>v.erase(unique(v.begin(), v.end()), v.end());</code></p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a><code>vector</code></h2><h2 id="queue-stack-deque"><a href="#queue-stack-deque" class="headerlink" title="queue stack deque"></a><code>queue</code> <code>stack</code> <code>deque</code></h2><h3 id="queue-队列"><a href="#queue-队列" class="headerlink" title="queue 队列"></a>queue 队列</h3><p>操作: push/emplace    pop    <strong>front</strong>    empty    size</p>
<p>pop &lt;— [0, 1, 2, 3] &lt;— push</p>
<p><strong>不支持下标访问</strong></p>
<h3 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h3><p>操作: push/emplace    pop    <strong>top</strong>    empty    size</p>
<p>[ ] &lt;—- push            [ ] —-&gt; pop</p>
<p><strong>不支持下标访问</strong></p>
<h3 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque 双端队列"></a>deque 双端队列</h3><p>操作: push_back/emplace_back    pop_back    push_front/emplace_front    pop_front    </p>
<p>front    back    empty    size</p>
<p><strong>支持下标访问</strong></p>
<h2 id="priority-queue-优先队列-堆"><a href="#priority-queue-优先队列-堆" class="headerlink" title="priority_queue 优先队列/堆"></a><code>priority_queue</code> 优先队列/堆</h2><p>==优先队列 / 堆 大顶堆 小顶堆==</p>
<p>操作: push/emplace    pop    <strong>top</strong>    empty    size</p>
<p>属于队列的一种 但pop时按大小进行pop</p>
<p>eg. &lt;— [3 2 100 0] &lt;— 执行pop操作依次pop出 100 3 2 0 (从大到小)</p>
<p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;</code></p>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a><code>set</code> 集合</h2><p>集合: set 有序唯一    </p>
<p>​         multiset 有序 不唯一    </p>
<p>​         unordered_set 无序 唯一</p>
<p>操作: insert erase find count </p>
<p>有序 元素支持 &lt;           无序 元素支持hash</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h2><p>第一个元素是string，第二个元素任意</p>
<p><code>map&lt;string, int&gt; mp;</code></p>
<p><code>multimap</code></p>
<p><code>unordered_map</code></p>
<p>操作：insert/emplace    erase find  [ ]</p>
<p>也可以通过下标运算通过key来输出value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string ,<span class="type">int</span>&gt; mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;xiaozhang&quot;</span> , <span class="number">99</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(&#123;<span class="string">&quot;xiaoli&quot;</span>, <span class="number">95</span>&#125;);</span><br><span class="line">mp.<span class="built_in">emplace</span>(<span class="string">&quot;guojia&quot;</span>, <span class="number">92</span>);</span><br><span class="line">cout &lt;&lt; mp[<span class="string">&quot;xiaozhang&quot;</span>] &lt;&gt; endl;<span class="comment">// 99</span></span><br><span class="line"><span class="comment">//如果输出map中原来没有的 会插入进map中，此时value是第二个参数的默认值</span></span><br><span class="line">cout &lt;&lt; mp[<span class="string">&quot;whatever&quot;</span>] &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//得到4</span></span><br></pre></td></tr></table></figure>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a><code>list</code></h2><p><code>std::list</code> 是C++标准模板库（STL）中的一个双向链表容器。它提供了高效的插入和删除操作，尤其是在链表的头部和尾部。与数组或 <code>std::vector</code> 不同，<code>std::list</code> 的元素不是连续存储的，而是通过指针连接的节点。</p>
<h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><p>以下是 <code>std::list</code> 的一些常用成员函数，按功能分类介绍：</p>
<p><strong>构造和析构</strong></p>
<ul>
<li><strong><code>std::list()</code></strong>：默认构造函数，创建一个空的链表。</li>
<li><strong><code>std::list(size_t n, const T&amp; value)</code></strong>：创建一个包含 <code>n</code> 个值为 <code>value</code> 的元素的链表。</li>
<li><strong><code>std::list(const std::list&amp; other)</code></strong>：拷贝构造函数，创建一个与 <code>other</code> 相同的链表。</li>
<li><strong><code>std::list(std::list&amp;&amp; other)</code></strong>：移动构造函数，将 <code>other</code> 的内容移动到新链表中。</li>
<li><p><strong><code>~std::list()</code></strong>：析构函数，销毁链表中的所有元素。</p>
<p><strong>迭代器</strong></p>
</li>
<li><p><strong><code>begin()</code></strong>：返回指向链表第一个元素的迭代器。</p>
</li>
<li><strong><code>end()</code></strong>：返回指向链表末尾（最后一个元素之后）的迭代器。</li>
<li><strong><code>rbegin()</code></strong>：返回指向链表最后一个元素的反向迭代器。</li>
<li><strong><code>rend()</code></strong>：返回指向链表开头（第一个元素之前）的反向迭代器。</li>
</ul>
<p><strong>容量</strong></p>
<ul>
<li><strong><code>empty()</code></strong>：检查链表是否为空，返回布尔值。</li>
<li><strong><code>size()</code></strong>：返回链表中元素的数量。</li>
<li><strong><code>max_size()</code></strong>：返回链表可以容纳的最大元素数量。</li>
</ul>
<p><strong>元素访问</strong></p>
<ul>
<li><strong><code>front()</code></strong>：返回链表中第一个元素的引用。</li>
<li><strong><code>back()</code></strong>：返回链表中最后一个元素的引用。</li>
</ul>
<p><strong>修改器</strong></p>
<ul>
<li><strong><code>push_front(const T&amp; value)</code></strong>：在链表头部插入一个值为 <code>value</code> 的元素。</li>
<li><strong><code>pop_front()</code></strong>：删除链表头部的元素。</li>
<li><strong><code>push_back(const T&amp; value)</code></strong>：在链表尾部插入一个值为 <code>value</code> 的元素。</li>
<li><strong><code>pop_back()</code></strong>：删除链表尾部的元素。</li>
<li><strong><code>insert(iterator pos, const T&amp; value)</code></strong>：在指定位置 <code>pos</code> 插入一个值为 <code>value</code> 的元素。</li>
<li><strong><code>erase(iterator pos)</code></strong>：删除指定位置 <code>pos</code> 的元素。</li>
<li><strong><code>clear()</code></strong>：删除链表中的所有元素。</li>
<li><strong><code>swap(std::list&amp; other)</code></strong>：交换两个链表的内容。</li>
</ul>
<p><strong>操作</strong></p>
<ul>
<li><strong><code>reverse()</code></strong>：反转链表中的元素顺序。</li>
<li><strong><code>sort()</code></strong>：对链表中的元素进行排序。</li>
<li><strong><code>unique()</code></strong>：删除链表中连续重复的元素。</li>
<li><strong><code>merge(std::list&amp; other)</code></strong>：将两个已排序的链表合并为一个有序链表。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用 <code>std::list</code> 的示例代码，展示了如何使用一些常见函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的链表</span></span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头部插入元素</span></span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">    myList.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表尾部插入元素</span></span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    myList.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出链表中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;链表中的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表头部的元素</span></span><br><span class="line">    myList.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表尾部的元素</span></span><br><span class="line">    myList.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出链表中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除头部和尾部后的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表中间插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>();</span><br><span class="line">    ++it; <span class="comment">// 移动到第二个元素</span></span><br><span class="line">    myList.<span class="built_in">insert</span>(it, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出链表中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;在链表中间插入元素后的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定位置的元素</span></span><br><span class="line">    myList.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出链表中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除指定位置的元素后的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    myList.<span class="built_in">reverse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出链表中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;反转链表后的元素：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> value : myList) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链表中的元素：3 2 1 4 5</span><br><span class="line">删除头部和尾部后的元素：2 1 4</span><br><span class="line">在链表中间插入元素后的元素：2 10 1 4</span><br><span class="line">删除指定位置的元素后的元素：2 1 4</span><br><span class="line">反转链表后的元素：4 1 2</span><br></pre></td></tr></table></figure>
<hr>
<p><img src="E:\资料\programming\c-resource\关键知识截图\STL usage.png" alt="STL usage"></p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记3</title>
    <url>/2024/10/03/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><p>作用域 定义变量只在{}内部生效</p>
<p>初始化 <code>if(int pow = x * x; pow &lt; 100)</code></p>
<p>通常书写</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;if branch&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;else if branch&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;else branch&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>书写规范:同样如果只有一行代码可写成一行增加代码的可阅读性</strong></p>
<p><code>if(condition) only_one_statement</code></p>
<h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (++i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (++i &lt; <span class="number">10</span>);</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>循环嵌套</strong></p>
<p>示例九九乘法表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">1</span>; a &lt;= <span class="number">9</span>; a++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> b = <span class="number">1</span>; b &lt;= a; b++)&#123;</span><br><span class="line">        cout &lt;&lt; format(<span class="string">&quot;&#123;&#125;*&#123;&#125;=&#123;:&lt;2&#125;&quot;</span>, a, b, a*b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳转控制"><a href="#跳转控制" class="headerlink" title="跳转控制"></a>跳转控制</h2><p>break 打破循环,直接结束循环</p>
<p>coutinue 继续循环 跳过后续未执行的循环体,跳到迭代语句和循环条件之前</p>
<p>goto 任意跳转至某一个标签</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">label:</span><br><span class="line">  <span class="keyword">if</span>(i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      sum += x;</span><br><span class="line">      i ++;</span><br><span class="line">      <span class="keyword">goto</span> label;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(init; expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression1:</span><br><span class="line">        branch1;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant-expression2:</span><br><span class="line">        branch2;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        branch3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记2</title>
    <url>/2024/10/02/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p>-用处 单独放在一个操作符前面 表示正负号反转</p>
<h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><p>a = a + 5 等效于 a+=5</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>C++转换示例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> d;</span><br><span class="line">cin &gt;&gt; d;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)d &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="常见数学函数"><a href="#常见数学函数" class="headerlink" title="常见数学函数"></a>常见数学函数</h2><p>先引入头文件<code>#include &lt;cmath&gt;</code>或者<code>#include &lt;math.h&gt;</code></p>
<p>返回的类型 函数名(参数的类型)     //例如乘方函数</p>
<p><code>double pow(double,double)//第一个参数底数,第二个参数指数</code></p>
<p><code>float pow(float,float)//函数名相同但类型不同,称之为函数重载</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">3</span>) &lt;&lt; endl; <span class="comment">//乘方</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">2</span>) &lt;&lt; endl;  <span class="comment">//开根号</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">abs</span>(<span class="number">-1</span>) &lt;&lt; endl;  <span class="comment">//绝对值</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fmod</span>(<span class="number">10</span>, <span class="number">3.3</span>) &lt;&lt; endl; <span class="comment">//浮点数取模</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">ceil</span> (<span class="number">3.1</span>) &lt;&lt; endl;<span class="comment">//浮点数向上取整</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">floor</span>(<span class="number">2.9</span>) &lt;&lt; endl;<span class="comment">//浮点数向下取整</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">round</span>(<span class="number">1.49</span>) &lt;&lt;endl;<span class="comment">//四舍五入</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">cbrt</span>(<span class="number">27</span>) &lt;&lt;endl;<span class="comment">//立方根</span></span><br><span class="line">cout &lt;&lt;<span class="built_in">hypot</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt;endl;<span class="comment">//勾股定理</span></span><br><span class="line"><span class="comment">//可到cmath相关文档进行查阅</span></span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>同是int类型得到结果会舍去小数部分 例如 1 / 2 得到结果 0</strong></p>
<p><strong>应用 1.0 / 2 = 0.5 使用浮点数得到结果</strong></p>
<h2 id="逻辑相关运算"><a href="#逻辑相关运算" class="headerlink" title="逻辑相关运算"></a>逻辑相关运算</h2><p>见C基础笔记</p>
<h2 id="三路比较运算符-lt-gt"><a href="#三路比较运算符-lt-gt" class="headerlink" title="三路比较运算符&lt;=&gt;"></a>三路比较运算符<code>&lt;=&gt;</code></h2><p>在 C++ 中，三路比较运算符（也称为空间船操作符）是一个功能强大的运算符，它允许你在一个表达式中比较三个值。这个运算符的符号是 <code>&lt;=&gt;</code>，被称为“三向比较运算符”或“比较运算符”。这个运算符在 C++20 标准中被引入</p>
<ul>
<li>0 表示两个值相等。</li>
<li>负值表示左边的值小于右边的值。</li>
<li>正值表示左边的值大于右边的值。</li>
</ul>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记14</title>
    <url>/2025/02/28/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B014/</url>
    <content><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>作用：一次编写，多场景复用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="comment">//具体值可以写任意不冲突的标识符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line">    T*date;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>), <span class="built_in">size</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">size_t</span> n) : <span class="built_in">data</span>(<span class="keyword">new</span> T[n]), <span class="built_in">size</span>(n) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Vector</span> () &#123;<span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="修饰词"><a href="#修饰词" class="headerlink" title="修饰词"></a>修饰词</h2><p>作用：限定或改变变量，函数，类，对象等行为或属性的关键字或符号</p>
<p><strong><code>const</code></strong>           只读，不可修改（对象，指针，指向const的指针，引用，成员函数，对象）</p>
<p>​                      作为函数参数时，额外支持了字面量或临时对象的传递，原本用普通的引用传参编译是无法通过的，因为函数内部修改并没有实参变量来承载</p>
<p>​                      在成员函数中，如果函数加上const修饰，那么函数中就无法修改成员变量</p>
<p><strong><code>mutable</code></strong>        可变的</p>
<p><strong><code>constexpr</code></strong>    修饰的变量才是真正意义上的常量</p>
<p><strong><code>static</code></strong>         在函数内变量前加上static修饰等价于将这个变量开到全局，但是只能在函数内访问；在类的成员变量中定义也是开在全局，不占用对象的内存，初始值需要在全局通过类名和作用域解析运算符来给予。特点是所有的对象共享这个静态成员变量，也就是说，它是属于类的，而不是属于对象的，全局独一份，也能通过类名直接访问。还能作用于成员函数</p>
<p><strong><code>inline</code></strong>          修饰函数，表示内联函数，在调用时会直接展开，省去函数调用的开销，性能会更高</p>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>定义：在正式编译前，预先对代码进行处理</p>
<h3 id="include"><a href="#include" class="headerlink" title="#include"></a><code>#include</code></h3><p><code>#include &lt;iostream&gt;</code>代表从标准库中查找文件</p>
<p><code>#include &quot;myheader.h&quot;</code>代表先从同目录中找，找不到再从标准库中查找</p>
<p>例如多文件联合编译时就需要使用引号，当然多文件编译还涉及到编译指令的修改，可以学习makefile或者cmake相关知识</p>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p><code>#define PI 3.14159265</code> 定义常量</p>
<p><code>#define SQRT(x) x * x</code> 还可以传参数</p>
<p><code>#define OUT(n) cout &lt;&lt; #n;</code>通过#加参数直接获取到这个参数的标识符</p>
<p>宏定义还可以使用多条语句，使用\进行换行，将反斜杠连接的内容都作为宏定义的一部分，但注意在条件语句中使用宏，如果不加花括号，只有一个语句会被包含在控制语句当中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OUT(n) cout &lt;&lt; #n;\</span></span><br><span class="line"><span class="meta">cout &lt;&lt; <span class="string">&quot;: &quot;</span>; \</span></span><br><span class="line"><span class="meta">cout &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//可以使用do while将其作为一个整体</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUT(n) do &#123;cout &lt;&lt; #n;\</span></span><br><span class="line"><span class="meta">cout &lt;&lt; <span class="string">&quot;: &quot;</span>; \</span></span><br><span class="line"><span class="meta">cout &lt;&lt; n &lt;&lt; endl; &#125; while(0)</span></span><br></pre></td></tr></table></figure>
<p><code>#define RELEASE</code> 单独定义一个标识符，结合条件预处理器使用</p>
<p><code>#ifdef        #ifndef        #if            #elif         #else         #endif</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RELEASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RELEASE</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;RELEASE&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	cout &lt;&lt;<span class="string">&quot;DEBUG&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//#endif 代表头文件的结束</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记4</title>
    <url>/2024/10/09/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>含义:存储一组相同数据类型元素的集合</p>
<p>定义方式:<code>类型 数组名[长度]</code> </p>
<p>类型:int char bool double等  (所有元素的类型相同)</p>
<p>数组名:变量命名规范 </p>
<p>长度:元素个数(正整数) </p>
<p>申明时确定,无法改变;内存中连续,快速访问</p>
<p>注意:C++标准不允许用变量 GCC编译器可以使用变量</p>
<p>数组的使用:通过数组名[下标(index)/索引]定位   ==注意是从0开始==</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> intArray[<span class="number">10</span>];<span class="comment">//定义数组,大小为0</span></span><br><span class="line"><span class="comment">//intArray[0]则表示数组中的第一个元素</span></span><br></pre></td></tr></table></figure>
<h2 id="数组的输入与输出"><a href="#数组的输入与输出" class="headerlink" title="数组的输入与输出"></a>数组的输入与输出</h2><p>C++中并不存在用cin或者cout直接输入或输出,可用循环控制挨个处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">    cin &gt;&gt; intArray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">    cout &lt;&lt; intArray[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>==C++11特性写法==</strong></p>
<p><strong>范围循环</strong> <code>for (类型 变量名: 数组)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> &amp;x: intArray)&#123;</span><br><span class="line">	cin &gt;&gt; x;</span><br><span class="line">&#125; <span class="comment">//或直接使用auto</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h2><h3 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h3><p><code>int intArray[10];</code> 数组中的数不确定</p>
<p><code>int intArray[10] = &#123;&#125;;</code>  数组里的数初始化为0</p>
<p><code>int intArray[10] = &#123;1, 2, 3&#125;;</code>  数组前三个数按顺序初始化,其余的数为0</p>
<p><code>int intArray[] = &#123;1, 2, 3&#125;;</code>  数组按{}内的数字初始化,长度为括号内数字的个数</p>
<h3 id="其他常见方法"><a href="#其他常见方法" class="headerlink" title="其他常见方法"></a>其他常见方法</h3><h4 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h4><p><algorithm>头文件中的fill函数:接受三个参数 起点 终点 以及值;代表将数组起点和终点的元素都赋值成对应的值</p>
<p>以长度为10为例<code>int intArray[10]</code></p>
<p><code>fill(intArray, intArray + 10, 1);</code> 意思是将10个元素赋值为1</p>
<p><code>fill(intArray + 3, intArray + 8, 2);</code> 将数组中34567赋值为2</p>
<h4 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h4><p><string.h>头文件中的memset函数: 接受三个参数 起点 值 内存长度</p>
<p><code>memset(intArray, 0, 40);</code></p>
<p><code>memset(intArray, 0, sizeof(intArray) * 10);</code></p>
<p><code>memset(intArray, 0, sizeof(intArray));</code></p>
<p><code>memset(intArray + 3, -1, sizeof(int) * 5);</code> </p>
<p>memset中如果值不等于0或者-1,结果会是很奇怪的数字</p>
<p>memset运行速度更快</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>概念:即元素不再单排成一排而是排成多排</p>
<p>定义方法:<code>int grid[4][5];</code></p>
<p>初始化也可用{}嵌套的方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> grid[<span class="number">4</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>访问时也可直接<code>grid[1][2]</code></p>
<p>也可以用<code>memset(grid, 0, sizeof(grid));</code>进行初始化</p>
<p>如果你想定义三维或者更多维,用更多的[]即可</p>
<h3 id="多维数组的输入与输出（范围循环）"><a href="#多维数组的输入与输出（范围循环）" class="headerlink" title="多维数组的输入与输出（范围循环）"></a>多维数组的输入与输出（范围循环）</h3><p>例如定义二维数组<code>int a[n][m];//n行m列</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; line: a)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x: line)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; line : a)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x: line)&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="多维数组的输出-（普通方法）"><a href="#多维数组的输出-（普通方法）" class="headerlink" title="多维数组的输出 （普通方法）"></a>多维数组的输出 （普通方法）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">        cout &lt;&lt; a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><p>添加头文件<code>string.h</code></p>
<p>memcpy复制矩阵<code>memcpy(b, a, sizeof(a));</code>把a的值复制到b上去</p>
<p><strong>内存的复制</strong>理解: 把a的内存地址,以b为起点,长度为a所占大小,复制到以b为起点的位置</p>
<h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p>头文件<code>&lt;algorithm&gt;</code>中<strong>swap</strong>直接交换例如<code>swap(arr[i],arr[j]);</code></p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>头文件<code>&lt;algorithm&gt;</code>中reverse进行旋转<code>reverse(arr,arr + n);</code></p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记6</title>
    <url>/2024/10/29/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B06/</url>
    <content><![CDATA[<h1 id="字符数组-amp-字符串"><a href="#字符数组-amp-字符串" class="headerlink" title="字符数组&amp;字符串"></a>字符数组&amp;字符串</h1><h2 id="定义-amp-初始化"><a href="#定义-amp-初始化" class="headerlink" title="定义&amp;初始化"></a>定义&amp;初始化</h2><p><code>char str[] = &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;;</code></p>
<p><code>char str[] = &quot;abcd&quot;;</code></p>
<p>==注意：字符串包含最后<code>\0</code>终止符,所以其实有五个元素==</p>
<p>因此字符串不完全等于字符数组, 终止字符可以直接用ASCII码值0来表示,字符形式需要用<code>\0</code>来表示</p>
<p>如果再字符串中想定义双引号需要加\表示转义 <code>char str[] = &quot;abc\&quot;&quot;;</code>否则遇到引号会认为字符结束了</p>
<p><strong>因此字符串其实就等价于有终止字符的字符数组</strong></p>
<p><strong>字符串实际上是字符数组的首地址，因此字符串变量可以被看作是一个指向字符的指针。当我们对字符串变量进行加法或减法运算时，实际上是在进行指针运算</strong></p>
<h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入/输出"></a>输入/输出</h2><p>可以用循环输入 <code>for(int i = 0;i &lt; n;i ++) cin &gt;&gt; str[i];</code></p>
<p>但一般不会告诉你有几个字符,所以用<code>scanf(&quot;%s&quot;, str);</code> 和 <code>cin &gt;&gt; str;</code>直接输入整个字符串是更好的选择 </p>
<p>==注意会带终止字符,占用地址更大==</p>
<ul>
<li><p>输出是会一直挨个遍历直到遇到了终止符,如果没有可能会输出乱码</p>
</li>
<li><p>普通输入会以空格分隔 例如 <code>abc def</code></p>
<p>则读取到的字符串是<code>abc</code></p>
<p>可以使用<code>cin.getline(str, 10);//第一个参数是字符数组,第二个参数是最大输入的字符个数</code></p>
<p>或者<code>stdio.h</code>中的<code>fgets(str, 10, stdin);//第三个参数表示从哪输入,stdin表示终端</code></p>
</li>
</ul>
<h2 id="lt-string-h-gt-中的常用函数"><a href="#lt-string-h-gt-中的常用函数" class="headerlink" title="&lt;string.h&gt;中的常用函数"></a><code>&lt;string.h&gt;</code>中的常用函数</h2><h3 id="strlen获取字符串长度"><a href="#strlen获取字符串长度" class="headerlink" title="strlen获取字符串长度"></a><code>strlen</code>获取字符串长度</h3><p><code>int len = strlen(str)</code>此长度并非数组长度而是以结束字符结尾的长度</p>
<h3 id="strcpy-复制字符串"><a href="#strcpy-复制字符串" class="headerlink" title="strcpy 复制字符串"></a><code>strcpy</code> 复制字符串</h3><p> <code>strcpy(dst, src)</code>将第二个字符串复制到第一个字符数组</p>
<p>要确保字符数组有足够的长度可以容纳归第二个字符串</p>
<p>==只会复制终止符前面的内容==</p>
<h3 id="strcat拼接"><a href="#strcat拼接" class="headerlink" title="strcat拼接"></a><code>strcat</code>拼接</h3><p><code>strcat(a,b)</code>将第二个字符串复制到第一个字符串的末尾,相当于两个字符串连接,同样需要确保内存大小</p>
<h3 id="strcmp比较大小"><a href="#strcmp比较大小" class="headerlink" title="strcmp比较大小"></a><code>strcmp</code>比较大小</h3><p><code>int order = strcmp(a,b);</code>比较两个字符串的字典序大小,返回其比较顺序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">order &lt; <span class="number">0</span> 		<span class="comment">// a &lt; b</span></span><br><span class="line">order == <span class="number">0</span>		<span class="comment">// a == b</span></span><br><span class="line">order &gt; <span class="number">0</span>		<span class="comment">// a &gt; b</span></span><br></pre></td></tr></table></figure>
<h3 id="strstr"><a href="#strstr" class="headerlink" title="strstr"></a><code>strstr</code></h3><p><code>char *c = strstr(a,b);</code> 判断字符串a是否包含字符串b,返回的结果是a中首次出现b的地址,类型为<code>char *c</code> (指针类型)</p>
<p>如果用结果减去a,即<code>int index = c - a;</code>则会返回下标;如果找不到b会返回<code>NULL</code>(NULL 等价于 0)</p>
<p><strong>直接判断结果可以知道a是否包含b</strong></p>
<h3 id="strtok-分隔字符串"><a href="#strtok-分隔字符串" class="headerlink" title="strtok 分隔字符串"></a><code>strtok</code> 分隔字符串</h3><p>将第一个字符串以第二个字符串中出现的字符进行分隔 </p>
<p>找到第一个非分隔符的位置返回地址,如果没有则返回NULL,同时将这个地址之后的第一个分隔符转化为终止符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;= one + two * (three / four)&quot;</span>;</span><br><span class="line"><span class="type">char</span> delimiter[] = <span class="string">&quot;=+*/() &quot;</span>; <span class="comment">//设定分隔值</span></span><br><span class="line"><span class="type">char</span>* token = <span class="built_in">strtok</span>(str, delimiter);</span><br></pre></td></tr></table></figure>
<p>输出token,则可以得到字符串one</p>
<p>并且<code>strtok</code>是比较特殊的函数,它在调用时会记录上一次分隔的位置,再次调用时,第一个参数只需要传入NULL,可通过下述代码,token会指向这些位置</p>
<p><img src="E:\Blog\img\bits\strtok.png" alt=""></p>
<p>通过while循环,提取原字符串的one two three four</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(token)&#123;</span><br><span class="line">    cout &lt;&lt; token &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span>(token == NUll) <span class="keyword">break</span>;</span><br><span class="line">    token = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, delimiter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="memset-amp-memcpy"><a href="#memset-amp-memcpy" class="headerlink" title="memset &amp; memcpy"></a><em><code>memset</code> &amp; <code>memcpy</code></em></h3><p>对内存进行操作,由于字符的内存恰好是1byte,故也可以看作是对字符进行操作</p>
<p><code>memset(arr, ch, sizeof(arr));</code></p>
<ul>
<li>第一个参数是内存的起始地址</li>
<li>第二个参数是设置的值,字符型(-128到127)</li>
<li>第三个参数是内存的长度 </li>
</ul>
<p><strong>代表将内存中从这个字符数组开始,对应长度的内存都赋值为第二个参数</strong></p>
<p>当然其他类型的数组也可以用<code>memset</code>啦</p>
<p>但是,比如int占4个字节,如果赋值为1,对应的二进制是由四个值为1的字节组成的,即在内存中以4个<strong>00000001</strong>组成,其结果是一个大整数(但是0和-1没有问题,因为内存中0的二进制都是0来表示,-1都是1来表示)</p>
<p><code>memcpy</code> 将一段内存从一个位置复制到另一个位置</p>
<p><code>memcpy(dst, src, sizeof(src));</code></p>
<ul>
<li>第一个参数代表目标地址</li>
<li>第二个参数代表被复制的地址</li>
<li>第三个参数代表要复制的内存长度</li>
</ul>
<p><strong>用途</strong>:比如数组无法直接用等于号赋值,所以如果想对数组进行赋值,就可以直接用<code>memcpy</code></p>
<h2 id="lt-stdlib-h-gt-中的常见函数"><a href="#lt-stdlib-h-gt-中的常见函数" class="headerlink" title="&lt;stdlib.h&gt;中的常见函数"></a><code>&lt;stdlib.h&gt;</code>中的常见函数</h2><p>==将字符串转化成数值==</p>
<p><code>atoi</code> &amp; <code>atoll</code> &amp; <code>atof</code></p>
<ul>
<li><strong>a</strong>代表ASCII码表</li>
<li><strong><code>i, f, ll</code></strong>分别对应<code>int</code>,<code>float类型</code>,<code>long long类型</code> (注意是代表float类型而不是转换成float,实际转化成double)</li>
</ul>
<p>通过这些函数可以将字符串转化成对应类型的数值</p>
<p>例如<code>cout &lt;&lt; atoi(&quot;123&quot;) &lt;&lt; endl;</code></p>
<p>字符串要是合法的数值,不然得到的结果是0.  例如<code>cout &lt;&lt; atof(&quot;abc&quot;) &lt;&lt; endl;</code></p>
<h2 id="lt-ctype-h-gt-中的常见函数"><a href="#lt-ctype-h-gt-中的常见函数" class="headerlink" title="&lt;ctype.h&gt;中的常见函数"></a><code>&lt;ctype.h&gt;</code>中的常见函数</h2><p>==用于判断字符的类型==  (具体如下图)</p>
<p><img src="E:\编程资料\c++\关键知识截图\ctype.png" alt="ctype"></p>
<h3 id="isprint"><a href="#isprint" class="headerlink" title="isprint"></a><code>isprint</code></h3><p>判断是否是可打印字符</p>
<h3 id="isspace"><a href="#isspace" class="headerlink" title="isspace"></a><code>isspace</code></h3><p>判断是否是空格</p>
<h3 id="isgraph"><a href="#isgraph" class="headerlink" title="isgraph"></a><code>isgraph</code></h3><p>判断是否是可绘制字符</p>
<h3 id="ispunct"><a href="#ispunct" class="headerlink" title="ispunct"></a><code>ispunct</code></h3><p>判断是否是标点符号</p>
<h3 id="isalnum"><a href="#isalnum" class="headerlink" title="isalnum"></a><code>isalnum</code></h3><p>判断字符串中的字符是否都是字母或数字</p>
<h3 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit"></a><code>isdigit</code></h3><p>判断是否是数字</p>
<h3 id="isalpha"><a href="#isalpha" class="headerlink" title="isalpha"></a><code>isalpha</code></h3><p>判断是否是字母</p>
<h3 id="isupper"><a href="#isupper" class="headerlink" title="isupper"></a><code>isupper</code></h3><p>判断是否是大写字母</p>
<h3 id="islower"><a href="#islower" class="headerlink" title="islower"></a><code>islower</code></h3><p>判断是否是小写字母</p>
<h3 id="toupper-amp-tolower"><a href="#toupper-amp-tolower" class="headerlink" title="toupper &amp; tolower"></a><code>toupper</code> &amp; <code>tolower</code></h3><p>返回字母的大写或者小写形式</p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="定义-amp-初始化-1"><a href="#定义-amp-初始化-1" class="headerlink" title="定义&amp;初始化"></a>定义&amp;初始化</h2><p>引入头文件 <code>include &lt;string&gt;</code></p>
<ul>
<li><p>初始可直接用字符串<code>string str1 = &quot;012345&quot;;</code> </p>
</li>
<li><p>或者使用另一个字符串 <code>string str2 = str1;</code></p>
</li>
<li><p>也可以像vector一样用长度加字符来初始化<code>string str3(6, &#39;#&#39;);</code></p>
</li>
<li><p>也可以用括号代替等于号 <code>string str4(str1);</code> 或者 <code>string str5(&quot;012345&quot;);</code></p>
</li>
<li><p><strong>利用<code>format</code>构造字符串形如：</strong></p>
<p><strong><code>format(&quot;&#123;0&#125;.zip/&#123;0&#125;/&#123;1&#125;/&#123;1&#125;.cpp&quot;, id, problem)</code></strong></p>
</li>
</ul>
<p><strong>这种用括号进行初始化的方式叫做构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用括号的好处在于可用添加更多的参数</span></span><br><span class="line"><span class="comment">//如果第一个参数是string类型,可以额外跟两个参数</span></span><br><span class="line"><span class="function">string <span class="title">str6</span><span class="params">(str1, <span class="number">2</span>)</span></span>; <span class="comment">//代表从第几个字符开始,使用多少个字符初始化</span></span><br><span class="line"><span class="function">string <span class="title">str7</span><span class="params">(str1, <span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果第一个参数是字符串类型,可以跟一个参数</span></span><br><span class="line"><span class="function">string <span class="title">str8</span><span class="params">(<span class="string">&quot;012345&quot;</span>, <span class="number">2</span>)</span></span>; <span class="comment">//代表使用多少个字符初始化</span></span><br><span class="line"><span class="function">string <span class="title">str8</span><span class="params">(&#123;<span class="number">48</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>&#125;)</span></span>; <span class="comment">//列表初始化</span></span><br><span class="line"><span class="function">string <span class="title">str10</span><span class="params">(str<span class="number">1.</span>begin() + <span class="number">1</span>, str<span class="number">1.</span>end() - <span class="number">1</span>)</span></span>; <span class="comment">//迭代器初始胡</span></span><br></pre></td></tr></table></figure>
<h2 id="输入-输出-1"><a href="#输入-输出-1" class="headerlink" title="输入/输出"></a>输入/输出</h2><p>输入输出可以直接当一个普通变量来进行</p>
<ul>
<li><p>使用<code>cin &gt;&gt; str;</code>也是根据空格分格;</p>
</li>
<li><p>如果想要输入整行,需要使用<code>getline(cin, str);</code></p>
</li>
<li><p>同时也可以使用范围循环来遍历<code>string</code>的每个字符</p>
<p><code>for (char&amp; c: str) &#123;&#125;;</code></p>
</li>
</ul>
<p>比起C语言的字符串简单了很多,不需要考虑终止符,非常的直观清晰</p>
<h2 id="string所支持的运算-amp-函数"><a href="#string所支持的运算-amp-函数" class="headerlink" title="string所支持的运算&amp;函数"></a><code>string</code>所支持的运算&amp;函数</h2><p>==<code>string</code>和<code>vector</code>很像,但<code>string</code>不属于容器==</p>
<h3 id="支持的运算符"><a href="#支持的运算符" class="headerlink" title="支持的运算符"></a>支持的运算符</h3><ul>
<li><strong>=</strong>  赋值运算</li>
<li><strong>&lt;=&gt;</strong>  比较运算</li>
<li><strong>[ ]</strong>  下标访问运算</li>
<li><strong>+</strong>  加法运算,字符串的拼接</li>
<li><strong>+=</strong> 直接将字符串加到末尾</li>
</ul>
<h3 id="支持的函数"><a href="#支持的函数" class="headerlink" title="支持的函数"></a>支持的函数</h3><h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><ul>
<li><p><strong>at</strong> —&gt; 带范围检测的下标访问</p>
</li>
<li><p><strong>front</strong> —&gt; 获取第一个字符</p>
</li>
<li><p><strong>back</strong> —&gt; 获取最后一个字符</p>
</li>
<li><p><strong>c_str</strong> —&gt; 返回C语言字符</p>
<p>比如<code>printf(&quot;%s&quot;, str.c_str());</code></p>
</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li><strong>begin</strong> —&gt; 起始迭代器</li>
<li><strong>end</strong> —&gt; 末尾迭代器</li>
</ul>
<h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><ul>
<li><strong>empty</strong> —&gt; 判断是否为空</li>
<li><strong>size</strong> —&gt; 获取字符个数</li>
<li><strong>length</strong> —&gt; 获取字符个数</li>
</ul>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><ul>
<li><p><strong>clear</strong> —&gt; 清空字符串</p>
</li>
<li><p><strong>resize</strong> —&gt; 改变大小</p>
</li>
<li><p><strong>push_back</strong> —&gt; 将字符插入末尾</p>
</li>
<li><p><strong>pop_back</strong> —&gt; 移除末尾字符</p>
</li>
<li><p><strong>insert</strong> —&gt; 插入字符(串)  </p>
<p>==除了可以使用迭代器表示位置外,还可以直接用下标表示==</p>
<p>例如<code>&quot;abc&quot;</code>插入后<code>str.insert(1, &quot;def&quot;);</code>得到字符串<code>&quot;abcdef&quot;</code></p>
</li>
<li><p><strong>erase</strong> —&gt; 删除子串 </p>
<p><code>str.erase(one, two);</code>同样可以用下标来表示</p>
<p>第一个参数表示开始删除的位置,第二个参数表示删除的个数;如果第二个参数不填则默认删除之后所有的元素</p>
</li>
<li><p><strong>append</strong> —&gt; 将字符串插入末尾</p>
</li>
<li><p><strong>replace</strong> —&gt; 替换一段字串</p>
<p><code>str.replace(1,2,&quot;xyz&quot;);</code></p>
<p>参数分别表示开始的位置,结束的位置,插入的元素(同样可以用下标表示位置)</p>
</li>
</ul>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ul>
<li><p><strong>find</strong> —&gt; 寻找字串首次出现的位置</p>
<p>对于字符串<code>&quot;This is island&quot;;</code></p>
<p><code>int pos = str.find(&quot;is&quot;);</code>返回第一次出现的下标</p>
<p>还可以指定从哪个下标开始查找 <code>int pos = str.find(&quot;is&quot;, 3);</code></p>
<p>如果找不到会返回<code>string::npos</code>(<code>string</code>的一个特殊值,代表没有找到,属于<code>unsigned long long</code>类型,具体值是无符号整数的最大值,因为内存中全是1,所以也等于有符号的-1;所以有些代码会直接判断find的值是否为-1,来表示是否找到,和使用<code>string::npos</code>来判断等价)</p>
</li>
<li><p><strong>substr</strong> —&gt; 返回指定子串</p>
<p><code>string sub = str.substr(2,3);</code>根据<strong>开始下标</strong>(第一个参数)和<strong>返回长度</strong>(第二个参数)来返回一个子串,如果不填第二个参数,则返回开始下标到结尾子串</p>
</li>
<li><p><strong>starts_with</strong> —&gt; 前缀判断</p>
<p><strong>ends_with</strong> —&gt; 后缀判断</p>
<p><code>bool res = str.starts_with(&quot;hel&quot;);</code></p>
</li>
</ul>
<h4 id="其他普通函数"><a href="#其他普通函数" class="headerlink" title="其他普通函数"></a>其他普通函数</h4><ul>
<li><code>stoi</code> —&gt; 将<code>string</code>转成数值(同样有<code>stoll</code>和<code>stod</code>的版本)</li>
<li><code>to_string</code> —&gt; 将数值转成<code>string</code></li>
<li>用<code>format</code>构造函数 —&gt; <code>string str = format(&quot;d = &#123;:.0f&#125;&quot;, d);</code></li>
</ul>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记7</title>
    <url>/2024/10/30/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B07/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*返回类型 函数名(参数列表)&#123;</span></span><br><span class="line"><span class="comment">    函数体;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        res *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="built_in">power</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>返回类型</strong></p>
<p>返回类型代表函数运算后返回的结果类型</p>
</li>
<li><p><strong>函数名</strong></p>
<p>函数的标识符</p>
</li>
<li><p><strong>参数列表</strong></p>
<p>调用函数时需要的数据以及类型</p>
</li>
<li><p><strong>函数体</strong></p>
<p>在函数内部通过传入的数据来得出结果的计算过程</p>
</li>
</ul>
<p>在调用函数时输入的参数称为<strong>实际参数</strong>(即<strong>实参</strong>),函数定义时的参数成为<strong>形式参数</strong>(即<strong>形参</strong>)</p>
<p>关键字==<code>return</code>==作用: </p>
<ul>
<li>返回值</li>
<li>结束函数</li>
</ul>
<p>函数类型为<code>void</code>时没有返回值,代表空,正常执行时不需要<code>return</code></p>
<h2 id="参数的引用"><a href="#参数的引用" class="headerlink" title="参数的引用"></a>参数的引用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br></pre></td></tr></table></figure>
<p>若不加&amp;符号,不会对实参进行改变.因此只有加上引用符号后才能对传递进来的实参进行修改</p>
<h2 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h2><p>对于<code>vector</code>,<code>string</code>这类复合数据类型,如果按数值来传递,相当于新建了一个同样大小的数据,同时将形参的数据赋值给函数的形参,性能低效</p>
<p><strong>因此尽可能用引用来传递非基础类型(因为指向同一个内存并不会发生数据的拷贝)</strong></p>
<p>同样如果传递数组不带引用符号的话,数组会发生隐式转换变成<strong>指针类型</strong></p>
<p>(<code>typeid</code>函数可获取数据类型)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">auto</span> &amp;arr)</span></span>;<span class="comment">//使用auto是比较危险的行为但可做题小范围使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">3</span>])</span></span>; <span class="comment">//要声明具体长度</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> N&gt;<span class="comment">//模板,C++高级特性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span> (&amp;arr)[N])</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a><code>main</code>函数</h1><h1 id="Lambda-函数"><a href="#Lambda-函数" class="headerlink" title="Lambda 函数"></a>Lambda 函数</h1><p>Lambda 函数（也称为匿名函数或 lambda 表达式）是 C++11 及以后版本中引入的一种方便的语法结构，它允许你在不定义传统函数的情况下创建函数对象。Lambda 函数通常用于简短的、一次性的函数，或者作为参数传递给算法，如 <code>std::sort</code>、<code>std::for_each</code> 等。</p>
<p>Lambda 函数的基本语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123; function_body &#125;</span><br></pre></td></tr></table></figure>
<p>其中各个部分的含义如下：</p>
<ol>
<li><strong>捕获子句（capture clause）</strong> <code>[capture]</code>：<ul>
<li>指定了 lambda 函数从封闭作用域（通常是包含它的函数）中捕获哪些变量。</li>
<li>可以捕获变量的值 <code>[=]</code> 或引用 <code>[&amp;]</code>，也可以通过名称 <code>[a, &amp;b]</code> 指定特定的变量捕获。</li>
<li>如果不需要捕获任何变量，可以省略捕获子句。</li>
</ul>
</li>
<li><strong>参数列表（parameter list）</strong> <code>(parameters)</code>：<ul>
<li>指定了 lambda 函数的参数，类似于传统函数的参数列表。</li>
<li>如果没有参数，可以省略参数列表，或者使用空括号 <code>()</code>。</li>
</ul>
</li>
<li><strong>返回类型（return type）</strong> <code>-&gt; return_type</code>：<ul>
<li>指定了 lambda 函数的返回类型。</li>
<li>如果 lambda 函数的返回类型可以由编译器推断，可以省略返回类型。</li>
</ul>
</li>
<li><strong>函数体（function body）</strong> <code>&#123; function_body &#125;</code>：<ul>
<li>包含了 lambda 函数的执行代码，类似于传统函数的函数体。</li>
</ul>
</li>
</ol>
<p>以下是一些 lambda 函数的例子：</p>
<p><strong>例子 1：无参数，无返回值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]() &#123; std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>例子 2：有参数，无返回值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) &#123; std::cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; x + y &lt;&lt; std::endl; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>例子 3：有参数，有返回值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>例子 4：捕获外部变量</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [a]() &#123; std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>例子 5：捕获外部变量并修改</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [&amp;a]() &#123; a = <span class="number">20</span>; &#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="comment">// 修改外部变量 a 的值</span></span><br></pre></td></tr></table></figure>
<p>Lambda 函数可以被存储在变量中，作为参数传递给函数，或者直接在需要的地方使用。它们是现代 C++ 编程中非常灵活和强大的工具。</p>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a><code>sort</code></h2><p><code>void sort(Iterator first, Iterator last, Function comparer);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comparer</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//a是否在b前面，a是否小于b</span></span><br><span class="line">    <span class="keyword">if</span>(a % <span class="number">2</span> != b % <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(arr, arr + <span class="number">9</span>, comparer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者直接写</span></span><br><span class="line"><span class="built_in">sort</span>(arr , arr + <span class="number">9</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">bool</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a % <span class="number">2</span> != b % <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="find-if"><a href="#find-if" class="headerlink" title="find_if"></a><code>find_if</code></h2><p>作用：查找范围内第一个满足条件的元素 </p>
<p>返回值为迭代器或者地址</p>
<p><code>Iterator find_if(Iterator first, Iterator last, Function matcher);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">matcher</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; target;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">100</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> target = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [target](<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; target;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong><code>[]</code>的意义是捕获，代表捕获一些变量使得可以在函数内正常访问</strong></p>
<h2 id="捕获"><a href="#捕获" class="headerlink" title="[]捕获"></a><code>[]</code>捕获</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y ,z;</span><br><span class="line"><span class="comment">//值捕获</span></span><br><span class="line">[x]() &#123;</span><br><span class="line">    x;</span><br><span class="line">    x = <span class="number">1</span>;<span class="comment">//错误的写法，因为不能在函数内修改值的量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引用捕获</span></span><br><span class="line"><span class="comment">//如果想修改x的值，需要加上引用，写作 [&amp;x]</span></span><br><span class="line">[=]() &#123;</span><br><span class="line">    <span class="comment">//写等于号代表捕获了x, y, z</span></span><br><span class="line">    x, y, z;</span><br><span class="line">&#125;</span><br><span class="line">[&amp;]() &#123;</span><br><span class="line">    <span class="comment">//只写引用符号代表引用捕获了x, y, z</span></span><br><span class="line">    x = y = z = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以混合使用</span></span><br><span class="line"><span class="comment">//初始化捕获</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">[x, init = x * x]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    x, init;</span><br><span class="line">    <span class="comment">//只在匿名函数内生效</span></span><br><span class="line">    <span class="comment">//加上mutable的修改 只在函数内部生效 和引用捕获不同	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断依据:</p>
<ul>
<li>如果想在函数内改变变量 使用引用捕获</li>
<li>vector string 等建议使用引用捕获</li>
</ul>
<p>==<code>mutable</code>==可改变的，加上mutable关键字之后可以改变捕获的值（只在函数内部生效，和引用捕获不同） <strong>加在括号和花括号之间</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> swap = [](<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b) &#123;  &#125;;<span class="comment">//花括号内写函数具体内容  </span></span><br></pre></td></tr></table></figure>
<h2 id="匿名函数的递归调用"><a href="#匿名函数的递归调用" class="headerlink" title="匿名函数的递归调用"></a>匿名函数的递归调用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> fib = [](<span class="keyword">auto</span>&amp; self, <span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>(self, x - <span class="number">1</span>) + <span class="built_in">self</span>(self, x - <span class="number">2</span>);</span><br><span class="line">&#125;;<span class="comment">//self代表函数自身</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">fib</span>(fib, <span class="number">10</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>递归</strong>，即调用函数自身。本质上是将问题拆解成更小规模的相同问题。</p>
<p>简单优化思路（==记忆化搜索==）：如果有重复计算，将结果保存下来</p>
<p>递归方法：</p>
<ul>
<li>确定问题</li>
<li>解决基准问题</li>
<li>拆解问题</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="斐波那契数列（Fibonacci）"><a href="#斐波那契数列（Fibonacci）" class="headerlink" title="斐波那契数列（Fibonacci）"></a>斐波那契数列（Fibonacci）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当出现重复问题时数据会成指数型增长,子问题会被重复计算多次.</p>
<p>可以在计算时将计算过的保存下来,并在计算时再判断是否计算过,用来优化性能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">saved</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(saved[n] == <span class="number">-1</span>)&#123;</span><br><span class="line">        saved[n] = <span class="built_in">fib</span>(n<span class="number">-1</span>) + <span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> saved[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="汉诺塔-honai"><a href="#汉诺塔-honai" class="headerlink" title="汉诺塔(honai)"></a>汉诺塔(honai)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> F, <span class="type">char</span> A, <span class="type">char</span> T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;move %d from %c to %c\n&quot;</span>, n, F, T);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">hanoi</span>(n - <span class="number">1</span>, F, T, A);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;move %d from %c to %c\n&quot;</span>, n, F, T);</span><br><span class="line">    <span class="built_in">hanoi</span>(n - <span class="number">1</span>, A, F, T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记5</title>
    <url>/2024/10/15/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="初步介绍"><a href="#初步介绍" class="headerlink" title="初步介绍"></a>初步介绍</h2><p>STL(Standard Template Library)，C++标准库的一部分，可以帮助我们处理常见的数据结构和算法。容器是STL的重要组成部分，用于存储和组织数据的对象。</p>
<h1 id="vertor"><a href="#vertor" class="headerlink" title="vertor"></a>vertor</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>动态数据容器</strong>：相比于数组在一开始就申明了大小，vector无需再申明时确定大小，可以做到动态调整容量，所以称之为动态数组</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>首先引入头文件<code>#include &lt;vector&gt;</code></li>
<li>定义方法为<code>vector &lt;类型&gt; 变量名</code>,例如<code>vector&lt;int&gt; vi</code>;</li>
<li>如果申明类似二维数组可写作<code>vector&lt;vertor&lt;int&gt;&gt; vvi;</code>  含义时外层容器的元素是<code>vector&lt;int&gt;</code>,内层容器的元素是<code>int</code>。<strong>比二维数组更灵活</strong></li>
</ul>
<h2 id="取值-索引"><a href="#取值-索引" class="headerlink" title="取值/索引"></a>取值/索引</h2><p>支持下标操作符,形如vi[0];同时,vector支持了通过at来访问元素.==区别at在访问时会检查下标是否越界,若越界在进行时会直接报错==</p>
<h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>由于vector在申明时内部没有任何数据,所以需要读取数据到某个变量,然后通过push_back将这个变量扔进容器中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    vi.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>或使用范围循环<code>for (auto&amp; x: arr) cin &gt;&gt; x;</code></strong></p>
<p>输出时可以通过size获取容器的大小,然后用for循环进行输出;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; vi.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">    cout &lt;&lt; vi[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或利用范围循环来遍历整个容器内的元素<code>for (auto&amp; x: vi) cout &lt;&lt; x &lt;&lt; endl;</code></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="普通vector容器初始化"><a href="#普通vector容器初始化" class="headerlink" title="普通vector容器初始化"></a>普通vector容器初始化</h3><ul>
<li>可以像普通数组一样定义大小<code>vector&lt;int&gt; v0(5);</code>,使得容器内被5个0填充;</li>
<li>如果想填充指定值,就在第二个参数上填上初始值<code>vector&lt;int&gt; v1(5, 1);</code></li>
<li>或者用花括号像数组一样定义初始值<code>vector&lt;int&gt; v2&#123;1, 2, 3&#125;</code></li>
<li>还可以用另一个vector进行初始化<code>vector&lt;int&gt; v3(v1);</code></li>
</ul>
<p>==如果初始化申明了vector的大小,就不用每次都用push_back挨个将数据丢入容器内,可以使用范围循环,和数组一<strong>样方便的进行数据输入==</strong></p>
<p><strong>利用C++的auto自动类型推导,可以更方便的进行多维vector的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v0</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: v0)&#123;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多维vector"><a href="#多维vector" class="headerlink" title="多维vector"></a>多维vector</h1><blockquote>
<p>引用<strong>sunny—ll</strong>的文章</p>
<p><a href="https://xas-sunny.blog.csdn.net/">https://xas-sunny.blog.csdn.net/</a></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>vector&lt;vector&lt;int&gt;&gt; table(size1, vector&lt;int&gt;(size2, 0));</code></p>
<p> <strong>代码说明：声明一个名为 table 的容器，其元素为 vector的容器。简单来说类似一个int型的二维数组</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/9f8090f5e8570d6ec09df71b46f71b87.png" alt="img"></p>
<p><strong>具体可理解如下</strong></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/ac917a95e3714d5a2f02c3b83eccc994.png" alt="img"></p>
<p>图中，我将外围容器table的初始化参数分成了两部分 <strong>A、B</strong> </p>
<ul>
<li><strong>A:</strong> table外围容器的大小</li>
<li><strong>B:</strong> table外围容器的内容，即 size1个vector型的元素。</li>
<li><strong>B1</strong>：内部容器的大小</li>
<li><strong>B2</strong>：内部容器的内容</li>
</ul>
<h2 id="vector-二维数组的-初始化"><a href="#vector-二维数组的-初始化" class="headerlink" title="vector 二维数组的 初始化"></a>vector 二维数组的 初始化</h2><h3 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h3><p>首先，要先知道：<strong>二维 vector</strong>如何获得行数和列数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c))；</span><br><span class="line"><span class="type">int</span> row = a.<span class="built_in">size</span>();          <span class="comment">//获取行数</span></span><br><span class="line"><span class="type">int</span> column = a[<span class="number">0</span>].<span class="built_in">size</span>();    <span class="comment">//获取列数</span></span><br><span class="line"><span class="comment">// （1）下面定义的是行为r，列为c的二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c));</span><br><span class="line"><span class="comment">// （2）下面定义的是行为r，列为c的二维数组，初始值为0</span></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">a</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c, <span class="number">0</span>)); </span><br><span class="line"><span class="comment">//	对每行的列进行操作</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">mat</span>(r);<span class="comment">//每行的定义</span></span><br><span class="line">mat[i].<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//这就是该第i-1行的插入一个元素，值为1</span></span><br></pre></td></tr></table></figure>
<h3 id="用resize来提前构建"><a href="#用resize来提前构建" class="headerlink" title="用resize来提前构建"></a>用resize来提前构建</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">new_mat</span>(r);<span class="comment">//注意这个r是不可缺少的，规定其有多少行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ;i&lt;r; i++) <span class="comment">//二维vector的初始化时有要求的</span></span><br><span class="line">&#123;</span><br><span class="line">   new_mat[i].<span class="built_in">resize</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vector-二维数组的-添加与删除"><a href="#vector-二维数组的-添加与删除" class="headerlink" title="vector 二维数组的 添加与删除"></a><strong>vector 二维数组的 添加与删除</strong></h2><h3 id="添加一行"><a href="#添加一行" class="headerlink" title="添加一行"></a>添加一行</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入一行数组：将in_row数组插入到第2行！ </span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in_row</span><span class="params">(<span class="number">5</span>,<span class="number">6</span>)</span></span>;<span class="comment">//初始化一个数组，包含5个元素并且全为6</span></span><br><span class="line">a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()<span class="number">+2</span>,in_row);</span><br></pre></td></tr></table></figure>
<h3 id="添加一列"><a href="#添加一列" class="headerlink" title="添加一列"></a>添加一列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line">	a[i].<span class="built_in">insert</span>(a[i].<span class="built_in">begin</span>()<span class="number">+2</span>,<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除一行"><a href="#删除一行" class="headerlink" title="删除一行"></a>删除一行</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + <span class="number">2</span>, a.<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="删除一列"><a href="#删除一列" class="headerlink" title="删除一列"></a>删除一列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除a的第二列</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i].<span class="built_in">erase</span>(a[i].<span class="built_in">begin</span>() + <span class="number">2</span>, a[i].<span class="built_in">begin</span>() + <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维数组的-输入"><a href="#二维数组的-输入" class="headerlink" title="二维数组的 输入"></a>二维数组的 输入</h2><p>例如<code>vector&lt;vector&lt;int&gt;&gt; urls(n);</code>为有n层的二维数据,使用范围循环输入数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; url: urls) &#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;<span class="comment">//表示这一行vector的数量</span></span><br><span class="line">    url.<span class="built_in">resize</span>(m);<span class="comment">//定义这一行vector的大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: url) cin &gt;&gt; x; <span class="comment">//输入数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维数组的-输出"><a href="#二维数组的-输出" class="headerlink" title="二维数组的 输出"></a>二维数组的 输出</h2><h3 id="引用符号-amp"><a href="#引用符号-amp" class="headerlink" title="引用符号 &amp;"></a>引用符号 &amp;</h3><p>例如定义一个二维容器players(2)</p>
<p>用<code>int CurrentPlayer = 0</code>,并后续用取模操作实现每次切换玩家,存储数据在数组的不同行,使用引用符使得代码更简洁易读 <code>auto &amp;player = players[CurrentPlayer]</code>,随后对其进行操作</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>使用范围循环对数组每一行进行求和计算代码ru’xai</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; player: players) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: player) sum += x;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; tri;</span><br><span class="line">  tri.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    tri.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(i + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 初始化当前行，所有元素为0</span></span><br><span class="line">    row[<span class="number">0</span>] = row[i] = <span class="number">1</span>; <span class="comment">// 每行的开始和结束元素为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">      row[j] = tri[i - <span class="number">1</span>][j - <span class="number">1</span>] + tri[i - <span class="number">1</span>][j]; <span class="comment">// 计算中间元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    tri.<span class="built_in">push_back</span>(row);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; line : tri) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : line) &#123;</span><br><span class="line">      cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="vector高级能力"><a href="#vector高级能力" class="headerlink" title="vector高级能力"></a><strong>vector</strong>高级能力</h1><p><strong>赋值运算&amp;比较运算</strong></p>
<p>可以将一个vector直接赋值给另一个vector</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v0&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1 = v0;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">v0 &lt; v2;</span><br></pre></td></tr></table></figure>
<p><strong>两个数组比较大小的方法(==字典序比较法==):</strong>挨个比较数组的元素,一旦不同,那么拥有较小元素的vector就是更小的,如果全部相同,则说明两个vector相同</p>
<h1 id="vector常用成员函数"><a href="#vector常用成员函数" class="headerlink" title="vector常用成员函数"></a>vector常用成员函数</h1><h2 id="front—获取vector的第一个元素"><a href="#front—获取vector的第一个元素" class="headerlink" title="front—获取vector的第一个元素"></a>front—获取vector的第一个元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">front</span>() &lt;&lt; endl</span><br></pre></td></tr></table></figure>
<h2 id="back—获取vector的最后一个元素"><a href="#back—获取vector的最后一个元素" class="headerlink" title="back—获取vector的最后一个元素"></a>back—获取vector的最后一个元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl</span><br></pre></td></tr></table></figure>
<h2 id="size—获取当前的元素个数"><a href="#size—获取当前的元素个数" class="headerlink" title="size—获取当前的元素个数"></a>size—获取当前的元素个数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl</span><br></pre></td></tr></table></figure>
<h2 id="empty—判断当前vector是否为空"><a href="#empty—判断当前vector是否为空" class="headerlink" title="empty—判断当前vector是否为空"></a>empty—判断当前vector是否为空</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">cout &lt;&lt; v.<span class="built_in">empty</span>() &lt;&lt; endl</span><br></pre></td></tr></table></figure>
<h2 id="clear—清空vector数据"><a href="#clear—清空vector数据" class="headerlink" title="clear—清空vector数据"></a>clear—清空vector数据</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>
<h2 id="push-back—将数据塞入vector末尾"><a href="#push-back—将数据塞入vector末尾" class="headerlink" title="push_back—将数据塞入vector末尾"></a>push_back—将数据塞入vector末尾</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h2 id="pop-back—将最后一个数据从vector中移除"><a href="#pop-back—将最后一个数据从vector中移除" class="headerlink" title="pop_back—将最后一个数据从vector中移除"></a>pop_back—将最后一个数据从vector中移除</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure>
<h2 id="resize—重新定义vector的大小"><a href="#resize—重新定义vector的大小" class="headerlink" title="resize—重新定义vector的大小"></a>resize—重新定义vector的大小</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>如果比原先小则删除末尾的元素;如果比原先大则用0来填充新增的元素,如果有第二个参数,<code>v.resize(5,1);</code>则改用第二个参数来填充</p>
<h2 id="begin-amp-end"><a href="#begin-amp-end" class="headerlink" title="begin&amp;end"></a>begin&amp;end</h2><p><code>v.begin()</code>&amp;<code>v.end()</code>,返回的是vector起始,末尾<strong>迭代器</strong></p>
<p><strong>迭代器</strong>分别指向的分别是容器始末,通过<strong>迭代器</strong>可以访问数组的始末</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = v.<span class="built_in">begin</span>(); iter ++)&#123;</span><br><span class="line">&#125; <span class="comment">//vector&lt;int&gt;::iterator是迭代器的类型,也可以用auto来代替</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter= v.<span class="built_in">begin</span>();iter != v.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">&#125; <span class="comment">//迭代器支持加法,但这并非算术运算,而是让迭代器指向下个元素</span></span><br></pre></td></tr></table></figure>
<p><img src="E:\Blog\source\img\vector-20241019142429502.png" alt="image-20241019142429502"></p>
<p>因此这个for循环的含义是:初始化迭代器指向第一个元素,然后不断指向下个元素,直到等于末尾迭代器,循环结束</p>
<p>迭代器并非元素本身,而是指向元素,所以想要获取迭代器所指向元素的值,需要用<code>*iter</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter= v.<span class="built_in">begin</span>();iter != v.<span class="built_in">end</span>(); iter++)&#123;</span><br><span class="line">    *iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>迭代器</strong>另一作用,定位位置;例如删除或增加某一个元素需要用迭代器指定位置</p>
<h2 id="erase—删除元素"><a href="#erase—删除元素" class="headerlink" title="erase—删除元素"></a>erase—删除元素</h2><p>通过<code>v.begin()</code>+下标来定位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>());<span class="comment">//只有一个参数代表输出指定位置的元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">beign</span>() + <span class="number">3</span>);<span class="comment">//若两个参数则表示删除某段连续的元素</span></span><br></pre></td></tr></table></figure>
<h2 id="insert—插入元素"><a href="#insert—插入元素" class="headerlink" title="insert—插入元素"></a>insert—插入元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">4</span>); <span class="comment">//第一个参数值代表插入的位置,后面的参数代表插入的内容</span></span><br><span class="line">v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;);<span class="comment">// 可以是普通的值也可以是一段花括号表示的数据</span></span><br><span class="line"><span class="comment">//还可以是另一个容器的范围 例如v1&#123;1,2,3&#125;;v2&#123;4,5,6&#125;</span></span><br><span class="line">v<span class="number">1.</span><span class="built_in">insert</span>(v<span class="number">1.</span><span class="built_in">end</span>(),v<span class="number">2.</span>begin,v<span class="number">2.</span><span class="built_in">end</span>());<span class="comment">//将容器放到另一个容器的尾部,得到新容器v1&#123;1,2,3,4,5,6&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="reverse-amp-emplace-back"><a href="#reverse-amp-emplace-back" class="headerlink" title="reverse&amp;emplace_back"></a>reverse&amp;emplace_back</h2><p>后续再做阐述</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记8</title>
    <url>/2024/11/27/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B08/</url>
    <content><![CDATA[<h1 id="指针和内存"><a href="#指针和内存" class="headerlink" title="指针和内存"></a>指针和内存</h1><p>指针存储的值并不是实际的内存数据，而是内存地址，通过指针可以直接对内存数据进行精细化的操作</p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>* ptr;   <span class="comment">//占8字节</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;i; <span class="comment">//&amp; 取地址符 可以获取变量的内存地址</span></span><br></pre></td></tr></table></figure>
<h3 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h3><p><code>void* ptr;</code>只是地址,没有指明类型信息,因此可以存储任意类型数据的地址,需要获取值的时候再转成对应的类型来取值,也被称为万能指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指针的值作为地址,实际解决需要通过指针获取地址对应的数据</span></span><br><span class="line"><span class="comment">//* 指针的取值,指针解引用</span></span><br><span class="line"><span class="type">int</span> var = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">cout &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">*ptr = <span class="number">2</span>; <span class="comment">//改变了原本的变量,指针指向的值也会跟着变,因为是对同一块内存数据的操作</span></span><br><span class="line">cout &lt;&lt; var &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line">var = <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line">*p; <span class="comment">//野指针, 无意义的指针</span></span><br><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="literal">nullptr</span>;<span class="comment">//空指针</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="指针和复合类型"><a href="#指针和复合类型" class="headerlink" title="指针和复合类型"></a>指针和复合类型</h2><h3 id="指针的特性"><a href="#指针的特性" class="headerlink" title="指针的特性"></a>指针的特性</h3><p>指针 —&gt; 内存地址 —&gt; uint64_t</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>,y = <span class="number">123</span>;</span><br><span class="line"><span class="type">uint64_t</span> addr = (<span class="type">uint64_t</span>)&amp;x;</span><br><span class="line">cout &lt;&lt; *(<span class="type">int</span>*)(addr + <span class="number">4</span>) &lt;&lt; endl; <span class="comment">//得到y的值</span></span><br><span class="line"><span class="comment">//指针在做地址偏移时会自动乘上类型的大小  (ptr + 1 * sizeof(int))</span></span><br><span class="line">cout &lt;&lt; ptr[<span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong>c++提供的语法糖,直接使用下标运算符进行地址偏移,但注意要在连续明确的内存下这样操作才有意义</strong></p>
<h3 id="数组-字符串-对象-函数"><a href="#数组-字符串-对象-函数" class="headerlink" title="数组    字符串    对象    函数"></a>数组    字符串    对象    函数</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>* ptr = arr;	<span class="comment">//进行隐式转化 转为了第一个元素的首地址</span></span><br><span class="line">cout &lt;&lt; ptr[i] &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>数组实际类型为 <code>int [5]</code> 因此定义一个指向数组的指针应该写 <code>int (*ptr) [5] = &amp;arr;</code></p>
<p>或者使用c++的<code>using</code>关键字写作<code>using Array5 = int[5];</code>就可以像普通变量一样定义数组和指向数组的指针<code>Array5* ptr = &amp;arr;</code></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><code>char *p;</code>字符指针,在输出时会一直+1做地址偏移,直到遇到内存为0的地址;通过这一特性,就带有终止符的字符数组首元素地址赋值给字符指针,就能把这个指针直接当字符串使用</p>
<p><code>char str[] = &quot;hello&quot;; char* pstr = str;</code> 输出得到结果<code>hello</code></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对于<code>vector</code>等stl容器,同样可以通过定义对应类型加星号来定义指针<code>vector&lt;int&gt;* ptr = &amp;vec;</code>, 可以像原来的变量<code>(*ptr).push_back(1);</code>来访问</p>
<p><strong><code>ptr-&gt;push_ack(2);</code></strong>c语言提供的语法糖,通过箭头进行访问</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数指针可以指向函数,并且可以像函数一样使用</p>
<h1 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h1><p>内存分为：代码区     <code>.text</code>    <code>.rodata</code></p>
<p>​                  全局区     <code>.data</code>(初始化)    <code>.bss</code>（未初始化）</p>
<p>​                  堆区    栈区</p>
<h2 id="数据的生命周期："><a href="#数据的生命周期：" class="headerlink" title="数据的生命周期："></a><strong>数据的生命周期：</strong></h2><ul>
<li><strong>出生              -&gt;    死亡</strong></li>
<li><strong>申请，分配   -&gt;    销毁，释放</strong></li>
<li><p><strong>可被访问       -&gt;    无法被访问</strong></p>
</li>
<li><p><strong>静态生命周期</strong>：代码区 全局区</p>
<p>程序启动 —&gt; 程序关闭</p>
</li>
<li><p><strong>动态生命周期</strong>：堆区</p>
<p>new —&gt; delete   手动申请时分配，手动删除时释放</p>
</li>
<li><p><strong>自动生命周期</strong>：栈区</p>
<p>在函数体内或花括号内定义时分配，函数结束或花括号结束释放</p>
</li>
</ul>
<h3 id="自动生命周期"><a href="#自动生命周期" class="headerlink" title="自动生命周期"></a>自动生命周期</h3><p>类似栈，不断入栈出栈的过程。栈的大小有限，使用过多会导致栈溢出。</p>
<h3 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h3><p><strong>全局变量</strong>  直接在函数体外定义即可（值是确定的，一定为0）</p>
<p><strong>静态变量</strong>  加上<code>static</code>关键字（这样定义的变量也是整个程序执行过程中都存在）</p>
<h3 id="动态生命周期"><a href="#动态生命周期" class="headerlink" title="动态生命周期"></a>动态生命周期</h3><p>c语言通过<code>&lt;stdlib.h&gt;</code>中的<code>malloc</code>申请内存（通过free释放）</p>
<p>c++新增关键字<code>new</code>来申请内存，申请时可以说明这块内存用来做什么（通过delete释放）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="type">int</span>;<span class="comment">//undefined</span></span><br><span class="line"><span class="type">int</span>* p2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]();<span class="comment">//0,0,0,0,0</span></span><br><span class="line"><span class="type">int</span>* (*p3)[<span class="number">5</span>] =(<span class="built_in">int</span>(*)[<span class="number">5</span>]) <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]();<span class="comment">//0,0,0,0,0</span></span><br><span class="line"><span class="type">int</span>* p4 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);<span class="comment">//5</span></span><br><span class="line"><span class="type">int</span>* p5 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//1,2,3,4,5</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;* p = <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;;<span class="comment">//[]</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;* p = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">1</span>);<span class="comment">//1,1,1,1,1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;* p = <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">5</span>,<span class="number">1</span>&#125;;<span class="comment">//5,1</span></span><br></pre></td></tr></table></figure>
<p>注意：只有<code>malloc</code>和<code>new</code>出来的数据在堆区，指针只是保存了堆区数据的地址，依然还是栈区的数据，也受自动生命周期的限制，所以遇到下一个花括号时就会被销毁。但此时堆区的数据仍然存在，这就是<strong>内存泄漏</strong>。</p>
<p>所以在使用完这块内存后，需要将这块内存进行释放。在释放完后最好将指针改成<code>nullptr</code>，否则会变成<strong>悬挂指针</strong>（野指针的一种，难以定位会造成不以察觉的bug）</p>
<p>c语言的另外两个函数<code>calloc</code> <code>realloc</code></p>
<p><strong>内存池</strong> 自行查阅</p>
<p><code>new Type[]</code>，<code>[]</code>代表元素个数</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p><code>share_ptr</code>    <code>unique_ptr</code>    <code>week_ptr</code></p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础笔记9</title>
    <url>/2024/12/21/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B09/</url>
    <content><![CDATA[<h1 id="纯数据结构体"><a href="#纯数据结构体" class="headerlink" title="纯数据结构体"></a>纯数据结构体</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>作用：将多个类型聚合成一个整体成为一个新类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    string name;<span class="comment">//成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line">Student stu, stus[<span class="number">100</span>];</span><br><span class="line">Student* pstu = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="comment">//可以像普通类型一样声明定义的变量,单个变量或者数组都可以</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    string name;<span class="comment">//成员变量</span></span><br><span class="line">&#125; stu, stus[<span class="number">10</span>];<span class="comment">//定义也可以直接在结构后面跟上变量名(匿名结构体)</span></span><br><span class="line"><span class="comment">//由于没有起名不可以正常的定义其他变量，但可以通过C++11增加的decltype关键字获取</span></span><br><span class="line"><span class="comment">//例如 decltype(Stu) stu2;</span></span><br></pre></td></tr></table></figure>
<p>访问成员变量只需要用<code>stu.score</code> <code>stu.name</code></p>
<p>使用举例eg</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> n = <span class="number">8</span>;</span><br><span class="line">Student* stus = <span class="keyword">new</span> Student[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>; ++ i)&#123;</span><br><span class="line">    cin &gt;&gt; stus[i].score &gt;&gt; stus[i].name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(stus, stus + n, [](Student &amp;a, Student &amp;b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="结构体特性"><a href="#结构体特性" class="headerlink" title="结构体特性"></a>结构体特性</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;; <span class="comment">//可以定义在全局</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;; <span class="comment">//可以定义在函数内(某个作用域内)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line">Student a = &#123;<span class="number">99</span>, <span class="string">&quot;小明&quot;</span>&#125;;</span><br><span class="line">Student a = &#123;<span class="number">99</span>&#125;;</span><br><span class="line">Student a&#123;<span class="number">99</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> a = Student&#123;<span class="number">99</span>&#125;;</span><br><span class="line">Student a&#123;.name = <span class="string">&quot;小明&quot;</span>&#125;</span><br><span class="line"><span class="comment">//可以直接进行赋值</span></span><br><span class="line">student b = a;</span><br><span class="line">student c;</span><br><span class="line">c = a;</span><br></pre></td></tr></table></figure>
<h3 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h3><p>会进行内存对齐而不是单纯相加</p>
<ul>
<li>以最大的类型作为宽度构建一个矩阵</li>
<li>按定义顺序依次摆放</li>
<li>每个数据只能拜访在其大小的倍数的位置</li>
<li>一行摆不下就新起一行</li>
<li>行×列就是实际大小</li>
</ul>
<p>可能会有一定的空间浪费,但会加速计算机的访问;如果相避免可以按内存大小定义</p>
<p>符合结构以成员最大宽度,数组以类型为宽度</p>
<h3 id="结构化绑定-C-17新增"><a href="#结构化绑定-C-17新增" class="headerlink" title="结构化绑定(C++17新增)"></a>结构化绑定(C++17新增)</h3><p>可以将结构体内的成员变量绑定到新的变量上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> [score, name] = stu;</span><br><span class="line"><span class="comment">//必须绑定所有成员变量,不可以只绑定一部分,也可以使用&amp;,避免产生数据拷贝</span></span><br><span class="line"><span class="comment">//新的变量名和成员变量不需要同名,只需要顺序对应上就行</span></span><br><span class="line"><span class="keyword">auto</span>&amp; [s, n] = stu;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[score, name] : arr)&#123;</span><br><span class="line">    cin &gt;&gt; score &gt;&gt; name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果只想使用某个变量则可以将不需要的变量这样写</span></span><br><span class="line"><span class="keyword">auto</span>&amp; [s, n] = stu;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[score, _] : arr)&#123;</span><br><span class="line">    cin &gt;&gt; score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="C-新增简便方式"><a href="#C-新增简便方式" class="headerlink" title="C++新增简便方式"></a>C++新增简便方式</h2><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a><code>pair</code></h3><p><code>pair</code> : 可以把两个数据类型进行聚合</p>
<p><code>pair&lt;int, string&gt; a;</code>由于没有命名,可以使用<code>a.first</code> <code>a.second</code>来访问</p>
<p>也支持<code>pair&lt;int,string&gt; a&#123;99, &quot;小明&quot;&#125;;</code>和结构化绑定 <code>auto &amp;[f, s] = a;</code></p>
<p>如果用<code>auto</code>定义需要使用<code>make_pair</code>函数来设置初始值 —&gt;<code>auto b = make_pair(80, &quot;jack&quot;);</code></p>
<p>只需要两个类型都支持大小比较<code>pair</code>也支持大小比较 <code>a &lt;=&gt; b;</code>(先比较第一个,如果相同再比较第二个)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">8</span>;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, string&gt;&gt; <span class="built_in">stus</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [s, f] : stus) &#123;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(stus.<span class="built_in">begin</span>(), stus.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a><code>tuple</code></h3><p>如果超过两个元素可以使用C++11提供的tuple</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, string&gt; a&#123;<span class="number">99</span>, <span class="number">7</span>, <span class="string">&quot;jack&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span>&amp;[score, id, name] = a;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">make_tuple</span>(<span class="number">80</span>, <span class="number">8</span>, <span class="string">&quot;mike&quot;</span>);</span><br><span class="line">a &lt;=&gt; b;</span><br><span class="line"><span class="comment">//访问成员变量时很麻烦,需写作 get&lt;0&gt;(a);之类的,因此通常先结构化绑定再操作</span></span><br></pre></td></tr></table></figure>
<h3 id="tie函数"><a href="#tie函数" class="headerlink" title="tie函数"></a><code>tie</code>函数</h3><p>绑定成员变量到已经定义的变量上,可以根据实际使用场景决定写法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> score, id;</span><br><span class="line">string name;</span><br><span class="line">pair&lt;<span class="type">int</span>, string&gt; pis&#123;<span class="number">99</span>, <span class="string">&quot;jack&quot;</span>&#125;;</span><br><span class="line">tuple&lt;<span class="type">int</span>, <span class="type">int</span>, string&gt; tiis&#123;<span class="number">80</span>, <span class="number">8</span> <span class="string">&quot;mike&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">tie</span>(score, name) = pis;</span><br><span class="line"><span class="built_in">tie</span>(score, id, name) = tiis;</span><br></pre></td></tr></table></figure>
<h2 id="vector补充"><a href="#vector补充" class="headerlink" title="vector补充"></a><code>vector</code>补充</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>, string&gt;&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="number">99</span>, <span class="string">&#x27;jack&#x27;</span>));</span><br><span class="line">vec.<span class="built_in">push_back</span>(&#123;<span class="number">95</span>, <span class="string">&quot;aly&quot;</span>&#125;);</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">80</span>, <span class="string">&quot;mike&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>对于符合类型最好用<code>emplace_back</code>函数</p>
<p>这个函数用于在容器的末尾就地构造一个新元素，而不是先复制或移动一个已存在的对象。<code>emplace_back</code> 通常用于性能优化，因为它避免了额外的复制或移动操作</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C-基础笔记1</title>
    <url>/2024/07/22/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/C-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="核心语法-1"><a href="#核心语法-1" class="headerlink" title="核心语法 1"></a>核心语法 1</h1><h4 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a><strong>1.注释</strong></h4><p><strong><em>==增加代码的可阅读性==</em></strong></p>
<p>//用于单行注释</p>
<p>/<em>    </em>/用于多行注释</p>
<h4 id="2-常量"><a href="#2-常量" class="headerlink" title="2.常量"></a><strong>2.常量</strong></h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">常量类型</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整型常量</td>
<td style="text-align:center">正数, 负数,0</td>
<td style="text-align:center">123</td>
</tr>
<tr>
<td style="text-align:center">实型常量</td>
<td style="text-align:center">所有带小数点的数字</td>
<td style="text-align:center">1.93  18.2</td>
</tr>
<tr>
<td style="text-align:center">字符常量</td>
<td style="text-align:center"><strong>单引号</strong> 引起来的 <strong>字母, 数字, 英文符号</strong></td>
<td style="text-align:center">‘A’ ‘C’</td>
</tr>
<tr>
<td style="text-align:center">字符串常量</td>
<td style="text-align:center"><strong>双引号</strong> 引起来</td>
<td style="text-align:center">“ABC”</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>扩展 1</strong>: 实型常量小数点前后可为 0, 可以忽略</li>
</ul>
<p>.93 等于 0.93                 18.等于 18.0</p>
<ul>
<li><p><strong>扩展 2</strong>: 科学计数法是实型常量, 但是要写 E</p>
<p>1.2340000 * 10^7^  不是常量, 是一个计算的过程</p>
<p>1.2340000E7 是实型常量</p>
</li>
</ul>
<h4 id="3-输出常量"><a href="#3-输出常量" class="headerlink" title="3.输出常量"></a>3.输出常量</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格式控制符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">单词</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整型</td>
<td style="text-align:center">%d</td>
<td style="text-align:center">decimal</td>
</tr>
<tr>
<td style="text-align:center">实型</td>
<td style="text-align:center">%f</td>
<td style="text-align:center">floating-point</td>
</tr>
<tr>
<td style="text-align:center">字符</td>
<td style="text-align:center">%c</td>
<td style="text-align:center">character</td>
</tr>
<tr>
<td style="text-align:center">字符串</td>
<td style="text-align:center">%s</td>
<td style="text-align:center">string</td>
</tr>
</tbody>
</table>
</div>
<p>printf(参数 1, 参数 2)</p>
<p>参数一: 输出内容的最终样式, 以 <strong>字符串</strong> 的形式体现</p>
<p>参数二: 填补的内容</p>
<p><strong>==输出换行== 可加上代码\n</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我的身高是: %f米\n&quot;</span>, <span class="number">1.85</span> );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;我的年龄是: %d岁\n&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="核心语法-2"><a href="#核心语法-2" class="headerlink" title="核心语法 2"></a>核心语法 2</h1><h4 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">整数</th>
<th style="text-align:center">小数</th>
<th style="text-align:center">字符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int, short, long, long long (C99)</td>
<td style="text-align:center">float, double</td>
<td style="text-align:center">char</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">short</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="type">long</span> b = <span class="number">10L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> c = <span class="number">10LL</span>;</span><br><span class="line">    <span class="comment">//注意 long, long long 要加后缀, 同时打印也要加</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld,%lld\n&quot;</span>, b, c);</span><br><span class="line">    <span class="comment">//利用 sizeof 测量数据类型字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="comment">//有符号整数, 无符号整数定义情况</span></span><br><span class="line">    <span class="comment">//signed 有符号整数 正数, 负数</span></span><br><span class="line">    <span class="comment">//unsigned 无符号整数 正数</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> e = <span class="number">-100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, e);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> f = <span class="number">-20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u\n&quot;</span>, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> a = <span class="number">3.14F</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">1.78</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>占用字节可用 sizeof 测量</li>
<li>后缀: long(L), long long(LL), float(F)</li>
</ul>
<h4 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.标识符"></a>2.标识符</h4><ul>
<li>由数字, 字母, 下划线组成</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
<li>区分大小写        ==aB 与 Ab 不一样==</li>
<li>用英文单词, 见名知意</li>
<li>变量名 全部小写</li>
</ul>
<h4 id="3-键盘录入"><a href="#3-键盘录入" class="headerlink" title="3.键盘录入"></a>3.键盘录入</h4><p>scanf, 是 scanner format 的缩写, C 语言提供的一个函数</p>
<p>获取用户在键盘上的数据, 并赋值给变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;变量名);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>切记不要写 <code>scanf(&quot;%d\n&quot;, &amp;a);</code> 否则 scanf 在读取时会尝试读取一个\n 此时按下 enter 没反应 不要犯错哦</strong></p>
<p>==先定义变量 再输出==</p>
<p><strong>字符串变量定义方式：</strong></p>
<p><strong>数据类型 变量名 [大小] = 字符串</strong></p>
<p>char str [4] = “aaa”;</p>
<p>内存大小计算方式:</p>
<p>英文: 一个字母, 符号, 数字占一个字节</p>
<p>中文: vs 和 vc 中, 默认一个中文占两个字节</p>
<p>结束标记: 一个字节</p>
<p>键盘录入多个数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type your name age height in order\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %f&quot;</span>,&amp;str, &amp;age, &amp;height);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;your name is %s,age %d, height %.2f&quot;</span>,str, age, height);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C-基础笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C-基础笔记2</title>
    <url>/2024/08/01/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/C-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h3 id="算术运算符-取余"><a href="#算术运算符-取余" class="headerlink" title="算术运算符: + - * / %(取余)"></a><strong>算术运算符: + - * / %(取余)</strong></h3><p>1.通用细节:</p>
<ul>
<li>整数计算,结果一定是整数</li>
</ul>
<p>例如10 / 3 结果为3 而得不到3.333</p>
<ul>
<li><p>小数计算,结果一定是小数</p>
</li>
<li><p>整数和小数计算,结果一定是小数</p>
</li>
<li><p>小数直接参与计算,结果可能不精确</p>
</li>
</ul>
<p>(计算机中存储方式为二进制,因此浮点数不准确)</p>
<p>2.取余细节</p>
<ul>
<li>运算的数据必须全部是整数</li>
<li>获取余数的正负,是跟第一个数字保持一致的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//键盘录入一个三位数，将其拆分为个位 十位 百位</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please type a number betweeen 100 and 999\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;BAI WEI SHI %d\n&quot;</span>,a / <span class="number">100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SHI WEI SHI %d\n&quot;</span>,a/<span class="number">10</span> % <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GE WEI SHI %d\n&quot;</span>,a % <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==计算时,数据模型不一样不能直接运算,需要转换成一样的,才能运算==</p>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p><strong>把一个取值范围小的,转成取值范围大的</strong></p>
<p>规则1: 取值范围小的,和取值范围大的,小的会自动升为大的,在进行运算</p>
<p>规则2: short char类型的数据在运算的时候,先提升为int,在进行计算</p>
<p>==<em>取值范围:</em>char&lt;short&lt;int&lt;long&lt;long long&lt;float&lt;double==</p>
<p>不同的数据类型进行计算,赋值等操作,会触发隐式转换</p>
<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p><strong>如果把取值范围大的,赋值给取值范围小的,就需要进行强制转换</strong></p>
<p>格式: 目标数据类型 变量名 = (目标数据类型)被强制转换的数据;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="type">short</span> i = (<span class="type">short</span>)b;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">short</span> s2 = <span class="number">20</span>;</span><br><span class="line">    <span class="type">short</span> result = (<span class="type">short</span>)(s1 + s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符相加"><a href="#字符相加" class="headerlink" title="字符相加"></a>字符相加</h4><p>字符跟数字进行转化的时候会查询ASCII码表(可直接用看)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="自增自减运算符-和—"><a href="#自增自减运算符-和—" class="headerlink" title="自增自减运算符:++和—"></a>自增自减运算符:++和—</h3><p>++表示 变量中的值+1; —表示 变量中的值-1;</p>
<p>++和—放在变量的前面或者后面,单独写一行结果是一样的</p>
<p>自增自减运算符应用场景:年龄增长,增减货物数量等等</p>
<p><strong>自增自减运算符扩展用法</strong></p>
<p>参与计算:例如定义 <code>int a = 10;</code></p>
<p><code>int b = a++;</code>先用后加,此时使用的是原来的值 得到b为10</p>
<p><code>int b = ++a;</code>先加后用,此时使用的是自增之后的值 得到b为11</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> k = i++ + ++i - --j - i--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line">    <span class="comment">//win: 11+11-7-11</span></span><br><span class="line">    <span class="comment">//mac: 10+12-4-12</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//windows:7</span></span><br><span class="line">    <span class="comment">//前缀优先于后缀</span></span><br><span class="line">    <span class="comment">//前缀统一自增/自减,再把结果拿出来用</span></span><br><span class="line">    <span class="comment">//int i = 10;</span></span><br><span class="line">    <span class="comment">//++i + ++i;</span></span><br><span class="line">    <span class="comment">//12  + 12 = 24</span></span><br><span class="line">    <span class="comment">//后缀统一先用,等整个表达式中变量用完了,再进行自减</span></span><br><span class="line">    <span class="comment">//int i = 10;</span></span><br><span class="line">    <span class="comment">//++i + ++i;</span></span><br><span class="line">    <span class="comment">// 10 + 10 = 20</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mac,linux:6</span></span><br><span class="line">    <span class="comment">//前缀和后缀优先级一样,从左到右依次计算,每一个前缀后缀都是一个独立的个体</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">直接赋值</td>
<td style="text-align:center">int a=10,将10的值赋值给a</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">加后赋值</td>
<td style="text-align:center">a+=b,将a+b的值给a(左右相加赋值给左边对右边没影响 下面同理)</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">减后赋值</td>
<td style="text-align:center">a-=b,将a-b的值给a</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">乘后赋值</td>
<td style="text-align:center">a*=b, 将a乘以b的值给a</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">除后赋值</td>
<td style="text-align:center">a/=b,将a除以b的商给a</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">取余赋值</td>
<td style="text-align:center">a%=b,将a除以b的余数给a</td>
</tr>
</tbody>
</table>
</div>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>==成立1(真) 不成立0(假)==</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">a==b 判断a是否等于b</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">a!=b 判断a是否不等于b</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">a&gt;b 判断a是否大于b</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">a&gt;=b 判断a是否大于等于b</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">a&lt;b 判断a是否小于b</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">a&lt;=b 判断a是否小于等于b</td>
</tr>
</tbody>
</table>
</div>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">与(而且)</td>
<td style="text-align:center">两边都为真,结果才是真(同时满足)</td>
</tr>
<tr>
<td style="text-align:center">\</td>
<td style="text-align:center">\</td>
<td style="text-align:center"></td>
<td>或(或者)</td>
<td>两边都为假,结果才是假(二选一)</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">非(取反)</td>
<td style="text-align:center">取反</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//键盘录入一个两位数，要求数字不能包含7</span></span><br><span class="line">    <span class="comment">//如果符合要求，输出1，不符合要求输出0</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type a num between 10 and 99\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="type">int</span> ge = a % <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> shi = a/<span class="number">10</span> %<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result = (ge != <span class="number">7</span> &amp;&amp; shi != <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>逻辑运算符的短路效果</strong></p>
<p>&amp;&amp;与(而且) ||或(或者)  具有<strong>短路</strong>效果</p>
<p>例如定义int a = 0;此时<code>printf(&quot;%d\n&quot;, a&gt;1 &amp;&amp; a&lt;10);</code>此时运行时,由于左边已得出结果为0可确定,因此右边不参与计算</p>
<p>==规则: 当左边的表达式能确定整个表达式的结果了,右边不会参与计算==</p>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>格式:关系表达式? 表达式1: 表达式2;</p>
<p>运行规则:先执行关系表达式(做一个判断).若结果成立,执行表达式1;若结果不成立,执行表达式2.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取三个变量中的最大值</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;type three numbers\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="type">int</span> d = a &gt; b ? a : b;</span><br><span class="line">    <span class="type">int</span> e = d &gt; c ? d : c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The biggest number is %d&quot;</span>,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>表达式1,表达式2,…..,表达式n</p>
<ul>
<li>从左到右</li>
<li>最后一个子表达式的结果, 是整个表达式的结果</li>
<li>优先级最低(永远是最后执行)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.变成绝对值</span></span><br><span class="line">    <span class="comment">//2.除以3获取余数</span></span><br><span class="line">    <span class="comment">//3.乘以10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Type a number\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="type">int</span> b = a &gt;= <span class="number">0</span> ? a : -a;</span><br><span class="line">    <span class="type">int</span> c = b % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> d = c * <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result is %d&quot;</span>,d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h3><ul>
<li><strong>小括号优先于所有</strong></li>
<li><strong>一元 &gt; 二元 &gt; 三元</strong></li>
<li><strong>&amp;&amp; &gt; || &gt; 赋值</strong></li>
</ul>
<p>一元:一个变量可以运算 </p>
<p>++ —(自增自减) + - !(正负取反)</p>
<p>二元:</p>
<p>乘除取余;加减;关系运算符(&gt;,&gt;=,&lt;,&lt;=,==,!=);逻辑 与(&amp;&amp;);逻辑 或(||)</p>
<p>三元:</p>
<p>三元运算符,赋值运算符,逗号运算符</p>
]]></content>
      <categories>
        <category>C-基础笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C-基础笔记3</title>
    <url>/2024/08/06/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/C-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h1 id="控制流程语句"><a href="#控制流程语句" class="headerlink" title="控制流程语句"></a>控制流程语句</h1><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>从上往下依次执行，是程序的默认的执行过程</p>
<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>程序在执行的过程中出现了岔路</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>作用:如果满足条件,才可以执行指定的代码(判断)</p>
<h4 id="格式1"><a href="#格式1" class="headerlink" title="格式1"></a>格式1</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)</span><br><span class="line">&#123;</span><br><span class="line">    语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细节1:在C语言当中,如果判断的结果是一个数字,非0表示条件成立,0表示条件不成立</p>
<p>细节2:如果大括号里面的语句体只有一行，那么大括号可以省略不写</p>
<h4 id="格式2"><a href="#格式2" class="headerlink" title="格式2"></a>格式2</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">    语句体A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    语句体B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="格式3"><a href="#格式3" class="headerlink" title="格式3"></a>格式3</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达A)&#123;</span><br><span class="line">    语句体A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(关系表达式B)&#123;</span><br><span class="line">    语句体B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(关系表达式C)&#123;</span><br><span class="line">    语句体C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    语句体N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>作用:把所有的选择一一列举出来,根据不同的条件任选其一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        语句体<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        语句体<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n;</span><br><span class="line">        <span class="keyword">break</span>;               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程:</p>
<ul>
<li>首先计算表达式的值</li>
<li>依次和case后面的值进行比较,如果有对应的值,就会执行相应的语句,在执行的过程中,遇到break就会结束</li>
<li>如果所有的case后面的值和表达式的值都不匹配,就会执行default里面的语句体,然后结束整个switch语句</li>
</ul>
<p>switch语句的更多细节:</p>
<ul>
<li>表达式:计算结果只能为 字符/整数</li>
<li>case: 值只能是 字符/整数 的字面量,不能是变量</li>
<li>case:值不能重复</li>
<li>break:表示中断,结束的意思,结束switch语句</li>
<li>default:所有情况都不匹配,执行该处的内容</li>
<li>default可以写在任意的位置,甚至可以省略不写</li>
</ul>
<h4 id="switch与if使用场景"><a href="#switch与if使用场景" class="headerlink" title="switch与if使用场景"></a>switch与if使用场景</h4><p>switch:有限个case进行匹配的情况,10个左右</p>
<p>if:一般是对一个范围进行判断</p>
<h4 id="case穿透"><a href="#case穿透" class="headerlink" title="case穿透"></a>case穿透</h4><ul>
<li>还是根据小括号中的表达式的结果去匹配对应的case</li>
<li>执行对应case里面的代码</li>
<li>如果在执行的过程中,遇到了break,那么直接结束整个switch.但是如果没有遇到break,就会继续执行下面case中的代码,直到遇到break,或者把整个switch中所有的代码全部执行完了,才会结束</li>
<li>case穿透只会往下穿,不会回到上面</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;whats the month\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;month);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the month is %d\n&quot;</span>, month);</span><br><span class="line">    <span class="keyword">switch</span>(month) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;its winter&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;its spring&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;its summer&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;its autumn&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;no such month bitch&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>循环:重复的执行某项事情</p>
<p>初始化语句+条件判断语句+条件控制语句+循环体语句</p>
<p>初始化语句:循环开始的条件</p>
<p>条件判断语句:循环结束的条件</p>
<p>条件控制语句:控制循环的次数</p>
<p>循环体语句:重复执行的代码</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for(初始化语句;条件判断语句;条件控制语句)</p>
<p>{</p>
<p>循环体语句</p>
<p>}</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wtf\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程:</p>
<ul>
<li>执行初始化语句</li>
<li>执行条件判断语句,看结果是否成立(成立,执行循环体语句;不成立,则结束循环)</li>
<li>执行条件控制语句</li>
<li>回到2继续执行条件判断语句</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//求和 1.定义变量用来累加数据 2.获取范围内的数据 3.打印sum</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//记得定义在循环的外面哦</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">        sum = i + sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变量的生命周期</strong>:变量只在所属的大括号中有效</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//对偶数和进行求和</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//判断，只有偶数才进行求和</span></span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;choose 2 numbers to define a scale\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a,&amp;b);</span><br><span class="line">    <span class="comment">//判断a b大小关系确认范围</span></span><br><span class="line">    <span class="keyword">if</span>(a == b) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fuck you\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> min = a &lt; b ? a : b;</span><br><span class="line">    <span class="type">int</span> max = a &gt; b ? a : b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you chose from %d to %d\n&quot;</span>,min,max);</span><br><span class="line">    <span class="comment">//定义变量计算个数,统计思想</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = min;i&lt;=max;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">6</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">8</span> ==<span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;there are %d numbers for ya\n&quot;</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=<span class="number">3</span>)&#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fuck you\n&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程与for循环类似</p>
<h3 id="for与while对比"><a href="#for与while对比" class="headerlink" title="for与while对比"></a>for与while对比</h3><p><strong>语法层面</strong></p>
<ul>
<li>for循环中,控制循环的变量,因为归属for循环的语法结构中,在for循环结束后,就不能再次被访问到了</li>
<li>while循环中,控制循环的变量,对于while来说不归属其语法结构中,在while循环结束后,该变量还可以继续使用</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>for循环中,知道循环的次数或者循环的范围</li>
<li>while循环中,不知道循环的次数和范围,只知道循环的结束条件</li>
</ul>
<p>举例1:累加求和1~100 for</p>
<p>举例2:循环读取文件中的内容 while</p>
<p>一次循环只能读取一个字母或者汉字,因此while更合适</p>
<h3 id="简单循环算法"><a href="#简单循环算法" class="headerlink" title="简单循环算法"></a>简单循环算法</h3><ul>
<li><p>考虑循环的过程 寻找实现办法</p>
</li>
<li><p><strong>使用更大的数据类型</strong>：如果可能，使用 <code>long double</code> 代替 <code>double</code> 来提高精度。</p>
</li>
<li><strong>调整终止条件</strong>：在循环条件中加入一个小的容差值，例如 <code>while (n &lt; 8844430 + 1e-6)</code>，以确保即使存在轻微的误差，循环也能正确地终止。</li>
<li><strong>使用整数逻辑</strong>：如果问题允许，使用整数逻辑来避免浮点数精度问题。例如，使用 <code>int</code> 类型和 10 的幂次来表示毫米数，但这需要更多的编码工作来处理大数运算。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 世界上最高的峰 珠穆朗玛峰（8844.43m = 8844430 mm）</span></span><br><span class="line"><span class="comment">     * 假如一张纸足够大 厚度0.1mm</span></span><br><span class="line"><span class="comment">     * 折多少次 可以折成这个高度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>; <span class="comment">// 纸张的初始厚度，以1/10毫米为单位</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">88444300</span>) &#123;</span><br><span class="line">        n *= <span class="number">2</span>; <span class="comment">// 纸张厚度翻倍</span></span><br><span class="line">        count++; <span class="comment">// 每次折叠都增加计数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修正输出语句，直接输出n的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;zui hou zhi de gao du shi %d \n&quot;</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;zhe le %d ci\n&quot;</span>, count); <span class="comment">// 输出折叠次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">    条件控制语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件判断语句);</span><br></pre></td></tr></table></figure>
<p>先执行再判断,循环体至少执行一次</p>
<h1 id="循环高级"><a href="#循环高级" class="headerlink" title="循环高级"></a>循环高级</h1><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lol\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lol\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lol\n&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h2><p>跳转控制语句:在循环的过程中,跳到其他语句上执行</p>
<h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>不能单独书写,只能写在switch,或者循环当中,表示结束 跳出的意思.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用for循环在100中获取数字</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//判断是否符合条件</span></span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; i % <span class="number">5</span> ==<span class="number">0</span>)&#123;</span><br><span class="line">        print(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>结束本次循环,继续下次循环</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;=<span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;<span class="comment">//跳过第三次循环进入第四次循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h2><p>eg.打印99乘法表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;=i; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d * %d = %d\t&quot;</span>,j,i,i*j);</span><br><span class="line">        <span class="comment">//其中\t表示制表打印,可自动对齐</span></span><br><span class="line">        <span class="comment">//制表符 长度可变的大空格</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>\t</strong>:制表符 长度可变的大空格</p>
<p>会根据前面字母的个数 在后面补空格, 让整体的长度达到8或者8的倍数,最少补一个,最多补八个</p>
<p>作用:打印表格数据时,可以对齐</p>
<p>eg.统计质数</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取小于等于整数n的质数数量</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 1.判读是否为质数</span></span><br><span class="line"><span class="comment">     * 2.添加范围</span></span><br><span class="line"><span class="comment">     * 3.统计</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="comment">//定义变量统计</span></span><br><span class="line">    <span class="type">int</span> countA = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j &lt;= <span class="number">100</span>;j++)&#123;</span><br><span class="line">       <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//统计在这个范围内有多少个数字能被number整除，判断是否为质数</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; j;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(j % i == <span class="number">0</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="comment">//后面的其他数字没必要判断了</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">           countA++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,countA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//累加1的1次方，2的2次方...10的10次方</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;<span class="comment">//定义变量记录数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="built_in">pow</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i;j++)&#123;</span><br><span class="line">            <span class="built_in">pow</span> = <span class="built_in">pow</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//内循环结束之后，就表示每一个单独的选项，已经有结果了</span></span><br><span class="line">        <span class="comment">//累加目的，每一个选项结果单独相加</span></span><br><span class="line">        res = res + <span class="built_in">pow</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C-基础笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C-基础笔记4</title>
    <url>/2024/09/16/C++%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/C-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p><strong>数组:一种容器 用来存储同种数据类型的多个值</strong></p>
<p>数组的定义</p>
<p>数组的初始化</p>
<p>元素访问</p>
<p>数组遍历</p>
<p>内存中的数组</p>
<p>数组的常见问题</p>
<p>数组的算法题</p>
<p>二维数组</p>
]]></content>
      <categories>
        <category>C-基础笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法 （greedy algorithm）</title>
    <url>/2025/07/15/Algo/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>==证明贪心策略的正确性很重要==</p>
<h1 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>从初始状态到目标状态，求一个最佳方案，有多个选择可以改变状态（状态转移方式）</p>
<p><strong>仅根据当前状态来制定</strong>的策略（故称之为贪心）</p>
<ul>
<li><p><strong>制定某个贪心的策略</strong></p>
</li>
<li><p><strong>证明这个策略的正确性</strong></p>
</li>
</ul>
<h2 id="集合选择问题"><a href="#集合选择问题" class="headerlink" title="集合选择问题"></a>集合选择问题</h2><p>有n个开区间[l , r]，选尽可能多的区间，使得这些区间两两不重叠</p>
<p>区间选择顺序是无关的，可以先排序再选择（例如以端点来排序）</p>
<p>启发：如果顺序无关可以先排序；区间排序可以用左右端点，中点，长度等进行组合，不断尝试；对于集合选择，剩余区间包含其他剩余区间</p>
<h2 id="截止日期问题"><a href="#截止日期问题" class="headerlink" title="截止日期问题"></a>截止日期问题</h2><p>启发：反向思考，从后往前思考做截至日期内价值最大的任务</p>
<h2 id="n个有序数组排序"><a href="#n个有序数组排序" class="headerlink" title="n个有序数组排序"></a>n个有序数组排序</h2><p>使用优先队列进行优化，寻找合适的状态</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><strong>贪心选择性质</strong>：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解。</li>
<li><strong>最优子结构</strong>：原问题的最优解包含子问题的最优解。</li>
</ul>
<h2 id="集体流程"><a href="#集体流程" class="headerlink" title="集体流程"></a>集体流程</h2><p>贪心问题的解决流程大体可分为以下三步。</p>
<ol>
<li><strong>问题分析</strong>：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及。</li>
<li><strong>确定贪心策略</strong>：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。</li>
<li><strong>正确性证明</strong>：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。</li>
</ol>
<p>确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要有以下原因。</p>
<ul>
<li><strong>不同问题的贪心策略的差异较大</strong>。对于许多问题来说，贪心策略比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了。</li>
<li><strong>某些贪心策略具有较强的迷惑性</strong>。当我们满怀信心设计好贪心策略，写出解题代码并提交运行，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是“部分正确”的，上文介绍的零钱兑换就是一个典型案例。</li>
</ul>
<p>为了保证正确性，我们应该对贪心策略进行严谨的数学证明，<strong>通常需要用到反证法或数学归纳法</strong>。</p>
<p>然而，正确性证明也很可能不是一件易事。如若没有头绪，我们通常会选择面向测试用例进行代码调试，一步步修改与验证贪心策略。</p>
<h2 id="贪心算法典型例题"><a href="#贪心算法典型例题" class="headerlink" title="贪心算法典型例题"></a>贪心算法典型例题</h2><p>贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题。</p>
<ul>
<li><strong>硬币找零问题</strong>：在某些硬币组合下，贪心算法总是可以得到最优解。</li>
<li><strong>区间调度问题</strong>：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。</li>
<li><strong>分数背包问题</strong>：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。</li>
<li><strong>股票买卖问题</strong>：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。</li>
</ul>
<hr>
<ul>
<li><strong>霍夫曼编码</strong>：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小。</li>
<li><strong>最小生成树</strong></li>
<li><strong>Dijkstra 算法</strong>：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>枚举算法</title>
    <url>/2025/07/14/Algo/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<h2 id="枚举算法"><a href="#枚举算法" class="headerlink" title="枚举算法"></a>枚举算法</h2><p>定义：在某个可能的解的集合中，按某个顺序依次检索元素，用题目给定的条件进行校验或计算</p>
<p>问题分类：</p>
<ul>
<li>是否存在    any of</li>
<li>找到第n个   find if   /     all of     /     none of</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stl中也有对应函数，只需要自己写条件即可</span></span><br><span class="line"><span class="built_in">any_of</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123; <span class="keyword">return</span> x &amp; <span class="number">1</span>; &#125;);<span class="comment">//all_of,none_of同理</span></span><br></pre></td></tr></table></figure>
<p><code>stl</code>提供了很多枚举函数<code>any of</code>    <code>all_of</code>    <code>none_of</code>    <code>find_if</code>    <code>max_element</code>    <code>min_element</code>    <code>accumulate</code></p>
<p><strong>子串转化</strong>：寻找子数组等于目标</p>
<p><strong>无限集枚举</strong>：初始化关键信息，再无限集中枚举，维护关键信息，关键信息符合条件时停止</p>
<p><strong>枚举的优化</strong>：裁剪枚举集</p>
<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="前缀和基础"><a href="#前缀和基础" class="headerlink" title="前缀和基础"></a>前缀和基础</h3><p>定义：表示从开头到当前位置所有元素的和，通过两处前缀和相加来获得区间和</p>
<p><strong>公式： <code>sum(L, R) = prefix[R] - prefix[L - 1]</code></strong></p>
<p>满足结合律，且存在可逆运算时可以推广到其他运算中：前缀积，前缀异或</p>
<h3 id="前缀积"><a href="#前缀积" class="headerlink" title="前缀积"></a>前缀积</h3><p><strong>公式：<code>mul(L, R) = prefix[R] / prefix[L - 1]</code></strong></p>
<p><strong>注意前缀积不要溢出</strong>，但是前缀积在计算过程中很容易变得很大，因此为了避免高精度的运算，通常会对结果进行取模    <code>prefix[i] = (prefix[i] * arr[i]) % mod</code>    但是此时他的逆运算就不是除法那么简单 —&gt;  乘法逆元（费马小定理    快速幂）</p>
<h3 id="前缀异或"><a href="#前缀异或" class="headerlink" title="前缀异或"></a>前缀异或</h3><p><strong>公式：<code>xor(L, R) = prefix[R] ^ prefix[L- 1]</code></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">partial_sum</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), xorsum.<span class="built_in">begin</span>(),</span><br><span class="line">           [](<span class="type">int</span> prev, <span class="type">int</span> cur)&#123;</span><br><span class="line">              <span class="keyword">return</span> prev ^ cur; </span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="二维前缀"><a href="#二维前缀" class="headerlink" title="二维前缀"></a>二维前缀</h3><p>计算方法：先对行进行前缀和计算，再对列进行前缀和计算</p>
<p>当前元素表示从左上角到当前位置所有元素的和，求某个子矩阵的和</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">左上</th>
<th style="text-align:center"></th>
<th style="text-align:center">上</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center"><strong>左</strong></td>
<td style="text-align:center">x</td>
<td style="text-align:center">目标元素</td>
</tr>
</tbody>
</table>
</div>
<p>计算目标子矩阵（图中2x2矩阵，可推广至大矩阵）公式：</p>
<p><strong>目标 - 左 - 上 + 左上</strong>    —&gt;    <strong>容斥原理</strong>（可扩展到三维甚至更高维度的前缀和）</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>差分是用于快速处理区间加减的算法，它是<strong>前缀和的逆运算</strong></p>
<p>差分表示后一个元素减去前一个元素，也就是当前位置元素减去前一个元素（i = 0时即ai）</p>
<p>可调用<code>stl</code>中的<code>adjacent_difference(a.begin(), a.end(), d.begin());</code></p>
<p>而手动遍历时记得从后往前遍历，避免覆盖</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>对[l, r]区间的每一个元素都加k &lt;=&gt; 对差分数组l的位置加k，r+1的位置减k（r+1会越界，可以多开一个位置），再进行一次前缀和运算得到目标数组</p>
<p><strong>a[l, r] + k &lt;=&gt; d[l] + k , d[r + 1] - k</strong></p>
<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>计算方法：先计算每一列的差分，再计算每一行的差分</p>
<p><strong>公式：当前元素 - 左 - 上 + 左上</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">（x1,  y1）</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">(x2, y2)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<p>对（x1, y1）到（x2，y2）的区间矩阵元素进行加减操作（例如+k）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">（x1,  y1） + k</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-k</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">(x2, y2)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">-k</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">+k</td>
</tr>
</tbody>
</table>
</div>
<p>也可以根据容斥原理推广到三维甚至更高维的差分算法</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>适用于前缀和的运算也适用差分</strong>，例如异或，乘法取模</p>
<p>对原数组某一个位置进行异或某个值，等价于对l和r+1的位置分别进行异或</p>
<p>然后进行一次前缀异或和</p>
<p>乘法取模也类似，但计算时需要用到乘法逆元</p>
<p><strong>有规律的差分=&gt; 多重差分</strong></p>
<p>等差数列的累加，多重差分再进行两次前缀和</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">3</th>
<th style="text-align:center">5</th>
<th style="text-align:center">7</th>
<th style="text-align:center">9</th>
<th style="text-align:center">11</th>
<th style="text-align:center">0</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>2</strong></td>
<td style="text-align:center"><strong>-11</strong></td>
<td style="text-align:center"><strong>0</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>3</strong></td>
<td style="text-align:center"><strong>-1</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:center"><strong>-13</strong></td>
<td style="text-align:center"><strong>11</strong></td>
</tr>
</tbody>
</table>
</div>
<p><strong>规律：</strong> <code>dL = a0;</code>        <code>dL+1 = -a0 + d;</code></p>
<p>​            <code>dR+1 = -a0 + d;</code>        <code>dR+2 = a0 + d(n - 1);</code></p>
<p><strong>多项式累加=&gt;多重差分</strong></p>
<p><code>addx = a + bx + cx^2 + dx^3 + ...</code></p>
<p>最高项加一次数的差分，再通过前缀和还原</p>
<p><strong>差分正负性=&gt;原数组增减性</strong></p>
<ul>
<li>如果差分数组都是正数，原数组一定单调递增</li>
<li>如果差分数组都是负数，原数组一定单调递减</li>
<li>如果差分数组都是0，原数组一定是相同的元素</li>
</ul>
<p>选择[L, R]让元素增加或减少    ==    让差分数组的某一个位置一个加，一个减</p>
<p>数组变得递增，递减，相等              数组变成正数，负数，零</p>
<p>差分数组第一个位置和越界R+1位置不影响原数组增减性，因此任选一个位置加减进行操作可以实现目标</p>
<h2 id="单调性枚举"><a href="#单调性枚举" class="headerlink" title="单调性枚举"></a>单调性枚举</h2><h3 id="单调递增枚举"><a href="#单调递增枚举" class="headerlink" title="单调递增枚举"></a>单调递增枚举</h3><p>二元组满足条件的最小值，单调递增</p>
<p><strong>滑动窗口：</strong>区间求和；时间、数轴的窗口、包含关系</p>
<p><strong>公式化：</strong> <strong>关键值，条件，维护，更新</strong></p>
<ul>
<li>判断是否满足条件</li>
<li><code>r</code>往后移动（添加一个元素），如何维护区间关键值</li>
<li><code>l</code>往后移动（删除一个元素），如何维护区间关键值 </li>
<li>找到满足条件的区间时，如何更新答案</li>
</ul>
<p><strong><code>match</code></strong>判断是否匹配的条件</p>
<p><strong><code>insert, remove</code></strong>增加右端点和删除左端点时对关键信息的维护</p>
<p><strong><code>update</code></strong>找到满足条件的区间时，如何更新答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = s, r = s; l &lt;= e; ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r &amp;&amp; <span class="built_in">match</span>(l, r - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">update</span>(l, r - <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">remove</span>(l ++, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &lt;= e) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(l, r++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">update</span>(l, r - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">remove</span>(l ++, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理可推演得<strong>单调递减枚举：</strong>二元组满足条件的最小值，单调递减</p>
<h3 id="四类求值"><a href="#四类求值" class="headerlink" title="四类求值"></a>四类求值</h3><p>最小满足，最大不满足，满足/不满足的方案数</p>
<h3 id="单调性剪枝"><a href="#单调性剪枝" class="headerlink" title="单调性剪枝"></a>单调性剪枝</h3><p>左边或下边比当前“差”，不用枚举</p>
<p>课程练习题 <code>leetcode 209 3 611 187</code></p>
<h2 id="单调双端队列"><a href="#单调双端队列" class="headerlink" title="单调双端队列"></a>单调双端队列</h2>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
</search>
